   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"hardware.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.gpio_write_bit,"ax",%progbits
  19              		.align	1
  20              		.global	gpio_write_bit
  21              		.thumb
  22              		.thumb_func
  24              	gpio_write_bit:
  25              	.LFB0:
  26              		.file 1 "hardware.c"
   1:hardware.c    **** /* *****************************************************************************
   2:hardware.c    ****  * The MIT License
   3:hardware.c    ****  *
   4:hardware.c    ****  * Copyright (c) 2010 LeafLabs LLC.
   5:hardware.c    ****  *
   6:hardware.c    ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:hardware.c    ****  * of this software and associated documentation files (the "Software"), to deal
   8:hardware.c    ****  * in the Software without restriction, including without limitation the rights
   9:hardware.c    ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:hardware.c    ****  * copies of the Software, and to permit persons to whom the Software is
  11:hardware.c    ****  * furnished to do so, subject to the following conditions:
  12:hardware.c    ****  *
  13:hardware.c    ****  * The above copyright notice and this permission notice shall be included in
  14:hardware.c    ****  * all copies or substantial portions of the Software.
  15:hardware.c    ****  *
  16:hardware.c    ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:hardware.c    ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:hardware.c    ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:hardware.c    ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:hardware.c    ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:hardware.c    ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:hardware.c    ****  * THE SOFTWARE.
  23:hardware.c    ****  * ****************************************************************************/
  24:hardware.c    **** 
  25:hardware.c    **** /**
  26:hardware.c    ****  *  @file hardware.c
  27:hardware.c    ****  *
  28:hardware.c    ****  *  @brief init routines to setup clocks, interrupts, also destructor functions.
  29:hardware.c    ****  *  does not include USB stuff. EEPROM read/write functions.
  30:hardware.c    ****  *
  31:hardware.c    ****  */
  32:hardware.c    **** 
  33:hardware.c    **** #include "hardware.h"
  34:hardware.c    **** /*
  35:hardware.c    **** void setPin(u32 bank, u8 pin) {
  36:hardware.c    ****     u32 pinMask = 0x1 << (pin);
  37:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  38:hardware.c    **** }
  39:hardware.c    **** 
  40:hardware.c    **** void resetPin(u32 bank, u8 pin) {
  41:hardware.c    ****     u32 pinMask = 0x1 << (16 + pin);
  42:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  43:hardware.c    **** }
  44:hardware.c    **** */
  45:hardware.c    **** void gpio_write_bit(u32 bank, u8 pin, u8 val) {
  27              		.loc 1 45 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
  46:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  47:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
  33              		.loc 1 47 0
  34 0000 0123     		movs	r3, #1
  35 0002 03FA01F1 		lsl	r1, r3, r1
  36              	.LVL1:
  46:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  37              		.loc 1 46 0
  38 0006 D2F10102 		rsbs	r2, r2, #1
  39              	.LVL2:
  40 000a 38BF     		it	cc
  41 000c 0022     		movcc	r2, #0
  42              		.loc 1 47 0
  43 000e 1301     		lsls	r3, r2, #4
  44 0010 9940     		lsls	r1, r1, r3
  45 0012 0161     		str	r1, [r0, #16]
  46 0014 7047     		bx	lr
  47              		.cfi_endproc
  48              	.LFE0:
  50              		.section	.text.readPin,"ax",%progbits
  51              		.align	1
  52              		.global	readPin
  53              		.thumb
  54              		.thumb_func
  56              	readPin:
  57              	.LFB1:
  48:hardware.c    **** }
  49:hardware.c    **** 
  50:hardware.c    **** bool readPin(u32 bank, u8 pin) {
  58              		.loc 1 50 0
  59              		.cfi_startproc
  60              		@ args = 0, pretend = 0, frame = 0
  61              		@ frame_needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              	.LVL3:
  51:hardware.c    ****     // todo, implement read
  52:hardware.c    ****     if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
  64              		.loc 1 52 0
  65 0000 0122     		movs	r2, #1
  66 0002 02FA01F1 		lsl	r1, r2, r1
  67              	.LVL4:
  68 0006 8368     		ldr	r3, [r0, #8]
  69 0008 0B42     		tst	r3, r1
  53:hardware.c    ****         return TRUE;
  54:hardware.c    ****     } else {
  55:hardware.c    ****         return FALSE;
  56:hardware.c    ****     }
  57:hardware.c    **** }
  70              		.loc 1 57 0
  71 000a 0CBF     		ite	eq
  72 000c 0020     		moveq	r0, #0
  73 000e 0120     		movne	r0, #1
  74              	.LVL5:
  75 0010 7047     		bx	lr
  76              		.cfi_endproc
  77              	.LFE1:
  79              		.section	.text.readButtonState,"ax",%progbits
  80              		.align	1
  81              		.global	readButtonState
  82              		.thumb
  83              		.thumb_func
  85              	readButtonState:
  86              	.LFB2:
  58:hardware.c    **** 
  59:hardware.c    **** bool readButtonState() {
  87              		.loc 1 59 0
  88              		.cfi_startproc
  89              		@ args = 0, pretend = 0, frame = 0
  90              		@ frame_needed = 0, uses_anonymous_args = 0
  91              		@ link register save eliminated.
  92              	.LVL6:
  60:hardware.c    ****     // todo, implement read
  61:hardware.c    **** 	bool state=FALSE;
  62:hardware.c    ****  #if defined(BUTTON_BANK) && defined (BUTTON_PIN) && defined (BUTTON_PRESSED_STATE)	
  63:hardware.c    ****     if (GET_REG(GPIO_IDR(BUTTON_BANK)) & (0x01 << BUTTON_PIN)) 
  64:hardware.c    **** 	{
  65:hardware.c    ****         state = TRUE;
  66:hardware.c    ****     } 
  67:hardware.c    **** 	
  68:hardware.c    **** 	if (BUTTON_PRESSED_STATE==0)
  69:hardware.c    **** 	{
  70:hardware.c    **** 		state=!state;
  71:hardware.c    **** 	}
  72:hardware.c    **** #endif
  73:hardware.c    **** 	return state;
  74:hardware.c    **** }
  93              		.loc 1 74 0
  94 0000 0020     		movs	r0, #0
  95 0002 7047     		bx	lr
  96              		.cfi_endproc
  97              	.LFE2:
  99              		.section	.text.strobePin,"ax",%progbits
 100              		.align	1
 101              		.global	strobePin
 102              		.thumb
 103              		.thumb_func
 105              	strobePin:
 106              	.LFB3:
  75:hardware.c    **** 
  76:hardware.c    **** void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
  77:hardware.c    **** {
 107              		.loc 1 77 0
 108              		.cfi_startproc
 109              		@ args = 4, pretend = 0, frame = 0
 110              		@ frame_needed = 0, uses_anonymous_args = 0
 111              	.LVL7:
 112 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 113              		.cfi_def_cfa_offset 32
 114              		.cfi_offset 4, -32
 115              		.cfi_offset 5, -28
 116              		.cfi_offset 6, -24
 117              		.cfi_offset 7, -20
 118              		.cfi_offset 8, -16
 119              		.cfi_offset 9, -12
 120              		.cfi_offset 10, -8
 121              		.cfi_offset 14, -4
 122              		.loc 1 77 0
 123 0004 9DF820A0 		ldrb	r10, [sp, #32]	@ zero_extendqisi2
 124 0008 1446     		mov	r4, r2
  78:hardware.c    ****     gpio_write_bit( bank,pin,1-onState);
 125              		.loc 1 78 0
 126 000a CAF10107 		rsb	r7, r10, #1
 127 000e FFB2     		uxtb	r7, r7
 128 0010 3A46     		mov	r2, r7
 129              	.LVL8:
  77:hardware.c    **** {
 130              		.loc 1 77 0
 131 0012 8046     		mov	r8, r0
 132 0014 8946     		mov	r9, r1
 133 0016 1E46     		mov	r6, r3
 134              		.loc 1 78 0
 135 0018 FFF7FEFF 		bl	gpio_write_bit
 136              	.LVL9:
 137              	.L5:
  79:hardware.c    **** 
  80:hardware.c    ****     u32 c;
  81:hardware.c    ****     while (count-- > 0) 
 138              		.loc 1 81 0 discriminator 1
 139 001c B4B1     		cbz	r4, .L4
 140              		.loc 1 81 0 is_stmt 0
 141 001e 3546     		mov	r5, r6
 142              	.L10:
 143              	.LVL10:
  82:hardware.c    **** 	{
  83:hardware.c    ****         for (c = rate; c > 0; c--)
 144              		.loc 1 83 0 is_stmt 1 discriminator 1
 145 0020 15B1     		cbz	r5, .L12
  84:hardware.c    **** 		{
  85:hardware.c    ****             asm volatile("nop");
 146              		.loc 1 85 0 discriminator 2
 147              	@ 85 "hardware.c" 1
 148 0022 00BF     		nop
 149              	@ 0 "" 2
  83:hardware.c    ****         for (c = rate; c > 0; c--)
 150              		.loc 1 83 0 discriminator 2
 151              		.thumb
 152 0024 013D     		subs	r5, r5, #1
 153              	.LVL11:
 154 0026 FBE7     		b	.L10
 155              	.L12:
  86:hardware.c    ****         }
  87:hardware.c    **** 		
  88:hardware.c    ****         gpio_write_bit( bank,pin,onState);
 156              		.loc 1 88 0
 157 0028 4046     		mov	r0, r8
 158 002a 4946     		mov	r1, r9
 159 002c 5246     		mov	r2, r10
 160 002e FFF7FEFF 		bl	gpio_write_bit
 161              	.LVL12:
  89:hardware.c    **** 		
  90:hardware.c    ****         for (c = rate; c > 0; c--)
 162              		.loc 1 90 0
 163 0032 3546     		mov	r5, r6
 164              	.LVL13:
 165              	.L7:
 166              		.loc 1 90 0 is_stmt 0 discriminator 1
 167 0034 15B1     		cbz	r5, .L13
  91:hardware.c    **** 		{
  92:hardware.c    ****             asm volatile("nop");
 168              		.loc 1 92 0 is_stmt 1 discriminator 2
 169              	@ 92 "hardware.c" 1
 170 0036 00BF     		nop
 171              	@ 0 "" 2
  90:hardware.c    ****         for (c = rate; c > 0; c--)
 172              		.loc 1 90 0 discriminator 2
 173              		.thumb
 174 0038 013D     		subs	r5, r5, #1
 175              	.LVL14:
 176 003a FBE7     		b	.L7
 177              	.L13:
  93:hardware.c    ****         }
  94:hardware.c    ****         gpio_write_bit( bank,pin,1-onState);
 178              		.loc 1 94 0
 179 003c 4046     		mov	r0, r8
 180 003e 4946     		mov	r1, r9
 181 0040 3A46     		mov	r2, r7
 182 0042 013C     		subs	r4, r4, #1
 183              	.LVL15:
 184 0044 FFF7FEFF 		bl	gpio_write_bit
 185              	.LVL16:
 186 0048 E4B2     		uxtb	r4, r4
 187              	.LVL17:
 188 004a E7E7     		b	.L5
 189              	.LVL18:
 190              	.L4:
 191 004c BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 192              		.cfi_endproc
 193              	.LFE3:
 195              		.section	.text.systemReset,"ax",%progbits
 196              		.align	1
 197              		.global	systemReset
 198              		.thumb
 199              		.thumb_func
 201              	systemReset:
 202              	.LFB4:
  95:hardware.c    ****     }
  96:hardware.c    **** }
  97:hardware.c    **** 
  98:hardware.c    **** void systemReset(void) {
 203              		.loc 1 98 0
 204              		.cfi_startproc
 205              		@ args = 0, pretend = 0, frame = 0
 206              		@ frame_needed = 0, uses_anonymous_args = 0
 207              		@ link register save eliminated.
  99:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 208              		.loc 1 99 0
 209 0000 0D4B     		ldr	r3, .L15
 100:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 210              		.loc 1 100 0
 211 0002 0E49     		ldr	r1, .L15+4
  99:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 212              		.loc 1 99 0
 213 0004 1A68     		ldr	r2, [r3]
 214 0006 42F00102 		orr	r2, r2, #1
 215 000a 1A60     		str	r2, [r3]
 216              		.loc 1 100 0
 217 000c 0C4A     		ldr	r2, .L15+8
 218 000e 1068     		ldr	r0, [r2]
 219 0010 0140     		ands	r1, r1, r0
 220 0012 1160     		str	r1, [r2]
 101:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 221              		.loc 1 101 0
 222 0014 1968     		ldr	r1, [r3]
 223 0016 21F08471 		bic	r1, r1, #17301504
 224 001a 21F48031 		bic	r1, r1, #65536
 225 001e 1960     		str	r1, [r3]
 102:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 226              		.loc 1 102 0
 227 0020 1968     		ldr	r1, [r3]
 228 0022 21F48021 		bic	r1, r1, #262144
 229 0026 1960     		str	r1, [r3]
 103:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 230              		.loc 1 103 0
 231 0028 1368     		ldr	r3, [r2]
 232 002a 23F4FE03 		bic	r3, r3, #8323072
 233 002e 1360     		str	r3, [r2]
 104:hardware.c    **** 
 105:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 234              		.loc 1 105 0
 235 0030 044B     		ldr	r3, .L15+12
 236 0032 0022     		movs	r2, #0
 237 0034 1A60     		str	r2, [r3]
 238 0036 7047     		bx	lr
 239              	.L16:
 240              		.align	2
 241              	.L15:
 242 0038 00100240 		.word	1073876992
 243 003c 0000FFF8 		.word	-117506048
 244 0040 04100240 		.word	1073876996
 245 0044 08100240 		.word	1073877000
 246              		.cfi_endproc
 247              	.LFE4:
 249              		.section	.text.setupCLK,"ax",%progbits
 250              		.align	1
 251              		.global	setupCLK
 252              		.thumb
 253              		.thumb_func
 255              	setupCLK:
 256              	.LFB5:
 106:hardware.c    **** }
 107:hardware.c    **** 
 108:hardware.c    **** void setupCLK(void) {
 257              		.loc 1 108 0
 258              		.cfi_startproc
 259              		@ args = 0, pretend = 0, frame = 0
 260              		@ frame_needed = 0, uses_anonymous_args = 0
 261              		@ link register save eliminated.
 109:hardware.c    ****     /* enable HSE */
 110:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
 262              		.loc 1 110 0
 263 0000 154B     		ldr	r3, .L24
 264 0002 1A68     		ldr	r2, [r3]
 265 0004 42F00112 		orr	r2, r2, #65537
 266 0008 1A60     		str	r2, [r3]
 267              	.L19:
 111:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
 268              		.loc 1 111 0 discriminator 1
 269 000a 1A68     		ldr	r2, [r3]
 270 000c 1248     		ldr	r0, .L24
 271 000e 9203     		lsls	r2, r2, #14
 272 0010 FBD5     		bpl	.L19
 112:hardware.c    **** 
 113:hardware.c    ****     /* enable flash prefetch buffer */
 114:hardware.c    ****     SET_REG(FLASH_ACR, 0x00000012);
 273              		.loc 1 114 0
 274 0012 124A     		ldr	r2, .L24+4
 275 0014 1221     		movs	r1, #18
 276 0016 1160     		str	r1, [r2]
 115:hardware.c    **** 
 116:hardware.c    ****     /* Configure PLL */
 117:hardware.c    **** //                                        0B100111010000010000000000 
 118:hardware.c    **** //                                        0B101000010000010000000000
 119:hardware.c    **** #define APB1PS 0B100
 120:hardware.c    **** #define APB1PS_SHIFT 8
 121:hardware.c    **** #define PLLSEL 0B1
 122:hardware.c    **** #define PLLSEL_SHIFT 16
 123:hardware.c    **** 
 124:hardware.c    **** #define PLLMF 10 
 125:hardware.c    **** #define PLLMF_SHIFT 18
 126:hardware.c    **** #define USBPS 0B10
 127:hardware.c    **** #define USBPS_SHIFT 22
 128:hardware.c    **** 
 129:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | (USBPS<< USBPS_SHIFT) | (PLLMF-2)<<PLLMF_SHIFT |  (PLLSEL
 277              		.loc 1 129 0
 278 0018 A2F6FC72 		subw	r2, r2, #4092
 279 001c 1168     		ldr	r1, [r2]
 280 001e 41F42101 		orr	r1, r1, #10551296
 281 0022 41F48061 		orr	r1, r1, #1024
 282 0026 1160     		str	r1, [r2]
 130:hardware.c    ****  //   SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0B100111010000010000000000);
 131:hardware.c    **** //									    987654321098765432109876543210							
 132:hardware.c    ****    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
 283              		.loc 1 132 0
 284 0028 0168     		ldr	r1, [r0]
 285 002a 41F08071 		orr	r1, r1, #16777216
 286 002e 0160     		str	r1, [r0]
 287              	.L21:
 133:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x03000000) == 0);         /* wait for it to come on */
 288              		.loc 1 133 0 discriminator 1
 289 0030 1968     		ldr	r1, [r3]
 290 0032 11F0407F 		tst	r1, #50331648
 291 0036 FBD0     		beq	.L21
 134:hardware.c    **** 
 135:hardware.c    ****     /* Set SYSCLK as PLL */
 136:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
 292              		.loc 1 136 0
 293 0038 1168     		ldr	r1, [r2]
 294 003a 41F00201 		orr	r1, r1, #2
 295 003e 1160     		str	r1, [r2]
 296              	.L23:
 137:hardware.c    ****     while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
 297              		.loc 1 137 0 discriminator 1
 298 0040 1168     		ldr	r1, [r2]
 299 0042 0907     		lsls	r1, r1, #28
 300 0044 FCD5     		bpl	.L23
 138:hardware.c    **** 	
 139:hardware.c    ****     pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
 301              		.loc 1 139 0
 302 0046 9A69     		ldr	r2, [r3, #24]
 303 0048 42F4FE72 		orr	r2, r2, #508
 304 004c 9A61     		str	r2, [r3, #24]
 140:hardware.c    **** 	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
 305              		.loc 1 140 0
 306 004e DA69     		ldr	r2, [r3, #28]
 307 0050 42F40002 		orr	r2, r2, #8388608
 308 0054 DA61     		str	r2, [r3, #28]
 309 0056 7047     		bx	lr
 310              	.L25:
 311              		.align	2
 312              	.L24:
 313 0058 00100240 		.word	1073876992
 314 005c 00200240 		.word	1073881088
 315              		.cfi_endproc
 316              	.LFE5:
 318              		.section	.text.setupLEDAndButton,"ax",%progbits
 319              		.align	1
 320              		.global	setupLEDAndButton
 321              		.thumb
 322              		.thumb_func
 324              	setupLEDAndButton:
 325              	.LFB6:
 141:hardware.c    **** }
 142:hardware.c    **** 
 143:hardware.c    **** 
 144:hardware.c    **** void setupLEDAndButton (void) {
 326              		.loc 1 144 0
 327              		.cfi_startproc
 328              		@ args = 0, pretend = 0, frame = 0
 329              		@ frame_needed = 0, uses_anonymous_args = 0
 330              		@ link register save eliminated.
 145:hardware.c    ****  // SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);
 146:hardware.c    ****  
 147:hardware.c    ****  #if defined(BUTTON_BANK) && defined (BUTTON_PIN) && defined (BUTTON_PRESSED_STATE)
 148:hardware.c    ****   SET_REG(GPIO_CR(BUTTON_BANK,BUTTON_PIN),(GPIO_CR(BUTTON_BANK,BUTTON_PIN) & crMask(BUTTON_PIN)) | 
 149:hardware.c    ****   
 150:hardware.c    ****   gpio_write_bit(BUTTON_BANK, BUTTON_PIN,1-BUTTON_PRESSED_STATE);// set pulldown resistor in case t
 151:hardware.c    ****  #endif
 152:hardware.c    ****   SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUT
 331              		.loc 1 152 0
 332 0000 034B     		ldr	r3, .L27
 333 0002 1A68     		ldr	r2, [r3]
 334              	.LVL19:
 335 0004 22F47002 		bic	r2, r2, #15728640
 336 0008 42F48012 		orr	r2, r2, #1048576
 337 000c 1A60     		str	r2, [r3]
 338 000e 7047     		bx	lr
 339              	.L28:
 340              		.align	2
 341              	.L27:
 342 0010 04100140 		.word	1073811460
 343              		.cfi_endproc
 344              	.LFE6:
 346              		.section	.text.setupFLASH,"ax",%progbits
 347              		.align	1
 348              		.global	setupFLASH
 349              		.thumb
 350              		.thumb_func
 352              	setupFLASH:
 353              	.LFB7:
 153:hardware.c    **** }
 154:hardware.c    **** 
 155:hardware.c    **** void setupFLASH() {
 354              		.loc 1 155 0
 355              		.cfi_startproc
 356              		@ args = 0, pretend = 0, frame = 0
 357              		@ frame_needed = 0, uses_anonymous_args = 0
 358              		@ link register save eliminated.
 156:hardware.c    ****     /* configure the HSI oscillator */
 157:hardware.c    ****     if ((pRCC->CR & 0x01) == 0x00) {
 359              		.loc 1 157 0
 360 0000 054B     		ldr	r3, .L33
 361 0002 1A68     		ldr	r2, [r3]
 362 0004 D107     		lsls	r1, r2, #31
 363 0006 03D4     		bmi	.L32
 364              	.LBB6:
 158:hardware.c    ****         u32 rwmVal = pRCC->CR;
 365              		.loc 1 158 0
 366 0008 1A68     		ldr	r2, [r3]
 367              	.LVL20:
 159:hardware.c    ****         rwmVal |= 0x01;
 368              		.loc 1 159 0
 369 000a 42F00102 		orr	r2, r2, #1
 370              	.LVL21:
 160:hardware.c    ****         pRCC->CR = rwmVal;
 371              		.loc 1 160 0
 372 000e 1A60     		str	r2, [r3]
 373              	.LVL22:
 374              	.L32:
 375              	.LBE6:
 161:hardware.c    ****     }
 162:hardware.c    **** 
 163:hardware.c    ****     /* wait for it to come on */
 164:hardware.c    ****     while ((pRCC->CR & 0x02) == 0x00) {}
 376              		.loc 1 164 0 discriminator 1
 377 0010 1A68     		ldr	r2, [r3]
 378 0012 9207     		lsls	r2, r2, #30
 379 0014 FCD5     		bpl	.L32
 165:hardware.c    **** }
 380              		.loc 1 165 0
 381 0016 7047     		bx	lr
 382              	.L34:
 383              		.align	2
 384              	.L33:
 385 0018 00100240 		.word	1073876992
 386              		.cfi_endproc
 387              	.LFE7:
 389              		.section	.text.checkUserCode,"ax",%progbits
 390              		.align	1
 391              		.global	checkUserCode
 392              		.thumb
 393              		.thumb_func
 395              	checkUserCode:
 396              	.LFB8:
 166:hardware.c    **** 
 167:hardware.c    **** bool checkUserCode(u32 usrAddr) {
 397              		.loc 1 167 0
 398              		.cfi_startproc
 399              		@ args = 0, pretend = 0, frame = 0
 400              		@ frame_needed = 0, uses_anonymous_args = 0
 401              		@ link register save eliminated.
 402              	.LVL23:
 168:hardware.c    ****     u32 sp = *(vu32 *) usrAddr;
 403              		.loc 1 168 0
 404 0000 0368     		ldr	r3, [r0]
 405              	.LVL24:
 169:hardware.c    **** 
 170:hardware.c    ****     if ((sp & 0x2FFE0000) == 0x20000000) {
 406              		.loc 1 170 0
 407 0002 0348     		ldr	r0, .L36
 408              	.LVL25:
 409 0004 1840     		ands	r0, r0, r3
 171:hardware.c    ****         return (TRUE);
 172:hardware.c    ****     } else {
 173:hardware.c    ****         return (FALSE);
 174:hardware.c    ****     }
 175:hardware.c    **** }
 410              		.loc 1 175 0
 411 0006 B0F10053 		subs	r3, r0, #536870912
 412              	.LVL26:
 413 000a 5842     		rsbs	r0, r3, #0
 414 000c 5841     		adcs	r0, r0, r3
 415 000e 7047     		bx	lr
 416              	.L37:
 417              		.align	2
 418              	.L36:
 419 0010 0000FE2F 		.word	805175296
 420              		.cfi_endproc
 421              	.LFE8:
 423              		.section	.text.nvicInit,"ax",%progbits
 424              		.align	1
 425              		.global	nvicInit
 426              		.thumb
 427              		.thumb_func
 429              	nvicInit:
 430              	.LFB10:
 176:hardware.c    **** 
 177:hardware.c    **** void jumpToUser(u32 usrAddr) {
 178:hardware.c    ****     typedef void (*funcPtr)(void);
 179:hardware.c    **** 
 180:hardware.c    ****     u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 181:hardware.c    ****     funcPtr usrMain = (funcPtr) jumpAddr;
 182:hardware.c    **** 
 183:hardware.c    ****     /* tear down all the dfu related setup */
 184:hardware.c    ****     // disable usb interrupts, clear them, turn off usb, set the disc pin
 185:hardware.c    ****     // todo pick exactly what we want to do here, now its just a conservative
 186:hardware.c    ****     flashLock();
 187:hardware.c    ****     usbDsbISR();
 188:hardware.c    ****     nvicDisableInterrupts();
 189:hardware.c    **** 	
 190:hardware.c    **** #ifndef HAS_MAPLE_HARDWARE	
 191:hardware.c    **** 	usbDsbBus();
 192:hardware.c    **** #endif
 193:hardware.c    **** 	
 194:hardware.c    **** // Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(
 195:hardware.c    ****     systemReset(); // resets clocks and periphs, not core regs
 196:hardware.c    **** 
 197:hardware.c    **** 
 198:hardware.c    ****     __MSR_MSP(*(vu32 *) usrAddr);             /* set the users stack ptr */
 199:hardware.c    **** 
 200:hardware.c    ****     usrMain();                                /* go! */
 201:hardware.c    **** }
 202:hardware.c    **** 
 203:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 431              		.loc 1 203 0
 432              		.cfi_startproc
 433              		@ args = 0, pretend = 0, frame = 0
 434              		@ frame_needed = 0, uses_anonymous_args = 0
 435              	.LVL27:
 204:hardware.c    ****     u32 tmppriority = 0x00;
 205:hardware.c    ****     u32 tmpreg      = 0x00;
 206:hardware.c    ****     u32 tmpmask     = 0x00;
 207:hardware.c    ****     u32 tmppre      = 0;
 208:hardware.c    ****     u32 tmpsub      = 0x0F;
 209:hardware.c    **** 
 210:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 211:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 212:hardware.c    **** 
 213:hardware.c    **** 
 214:hardware.c    ****     /* Compute the Corresponding IRQ Priority --------------------------------*/
 215:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 436              		.loc 1 215 0
 437 0000 184B     		ldr	r3, .L39
 203:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 438              		.loc 1 203 0
 439 0002 30B5     		push	{r4, r5, lr}
 440              		.cfi_def_cfa_offset 12
 441              		.cfi_offset 4, -12
 442              		.cfi_offset 5, -8
 443              		.cfi_offset 14, -4
 444              		.loc 1 215 0
 445 0004 DB68     		ldr	r3, [r3, #12]
 216:hardware.c    ****     tmppre = (0x4 - tmppriority);
 217:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 218:hardware.c    **** 
 219:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 446              		.loc 1 219 0
 447 0006 4478     		ldrb	r4, [r0, #1]	@ zero_extendqisi2
 215:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 448              		.loc 1 215 0
 449 0008 DB43     		mvns	r3, r3
 450 000a C3F30223 		ubfx	r3, r3, #8, #3
 451              	.LVL28:
 216:hardware.c    ****     tmppre = (0x4 - tmppriority);
 452              		.loc 1 216 0
 453 000e C3F10402 		rsb	r2, r3, #4
 454              	.LVL29:
 455              		.loc 1 219 0
 456 0012 04FA02F2 		lsl	r2, r4, r2
 457              	.LVL30:
 217:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 458              		.loc 1 217 0
 459 0016 0F24     		movs	r4, #15
 460 0018 DC40     		lsrs	r4, r4, r3
 461              	.LVL31:
 220:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 462              		.loc 1 220 0
 463 001a 8178     		ldrb	r1, [r0, #2]	@ zero_extendqisi2
 221:hardware.c    **** 
 222:hardware.c    ****     tmppriority = tmppriority << 0x04;
 223:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 464              		.loc 1 223 0
 465 001c 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 466              	.LVL32:
 220:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 467              		.loc 1 220 0
 468 001e 0C40     		ands	r4, r4, r1
 469              	.LVL33:
 470 0020 1443     		orrs	r4, r4, r2
 471              	.LVL34:
 472              		.loc 1 223 0
 473 0022 03F00301 		and	r1, r3, #3
 474 0026 C900     		lsls	r1, r1, #3
 222:hardware.c    ****     tmppriority = tmppriority << 0x04;
 475              		.loc 1 222 0
 476 0028 2401     		lsls	r4, r4, #4
 477              	.LVL35:
 224:hardware.c    **** 
 225:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 226:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 478              		.loc 1 226 0
 479 002a FF22     		movs	r2, #255
 223:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 480              		.loc 1 223 0
 481 002c 8C40     		lsls	r4, r4, r1
 482              	.LVL36:
 483              		.loc 1 226 0
 484 002e 8A40     		lsls	r2, r2, r1
 485 0030 03F0FC03 		and	r3, r3, #252
 486 0034 03F16043 		add	r3, r3, #-536870912
 487 0038 03F56143 		add	r3, r3, #57600
 225:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 488              		.loc 1 225 0
 489 003c D3F80053 		ldr	r5, [r3, #768]
 490              	.LVL37:
 227:hardware.c    ****     tmpreg &= ~tmpmask;
 491              		.loc 1 227 0
 492 0040 25EA0201 		bic	r1, r5, r2
 493              	.LVL38:
 228:hardware.c    ****     tmppriority &= tmpmask;
 494              		.loc 1 228 0
 495 0044 2240     		ands	r2, r2, r4
 496              	.LVL39:
 229:hardware.c    ****     tmpreg |= tmppriority;
 497              		.loc 1 229 0
 498 0046 0A43     		orrs	r2, r2, r1
 499              	.LVL40:
 230:hardware.c    **** 
 231:hardware.c    ****     rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 500              		.loc 1 231 0
 501 0048 C3F80023 		str	r2, [r3, #768]
 502              	.LVL41:
 232:hardware.c    **** 
 233:hardware.c    ****     /* Enable the Selected IRQ Channels --------------------------------------*/
 234:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 503              		.loc 1 234 0
 504 004c 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 235:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 505              		.loc 1 235 0
 506 004e 0122     		movs	r2, #1
 507              	.LVL42:
 234:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 508              		.loc 1 234 0
 509 0050 5909     		lsrs	r1, r3, #5
 510              		.loc 1 235 0
 511 0052 03F01F03 		and	r3, r3, #31
 512 0056 02FA03F3 		lsl	r3, r2, r3
 234:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 513              		.loc 1 234 0
 514 005a 034A     		ldr	r2, .L39+4
 515 005c 42F82130 		str	r3, [r2, r1, lsl #2]
 516 0060 30BD     		pop	{r4, r5, pc}
 517              	.L40:
 518 0062 00BF     		.align	2
 519              	.L39:
 520 0064 00ED00E0 		.word	-536810240
 521 0068 00E100E0 		.word	-536813312
 522              		.cfi_endproc
 523              	.LFE10:
 525              		.section	.text.nvicDisableInterrupts,"ax",%progbits
 526              		.align	1
 527              		.global	nvicDisableInterrupts
 528              		.thumb
 529              		.thumb_func
 531              	nvicDisableInterrupts:
 532              	.LFB11:
 236:hardware.c    **** }
 237:hardware.c    **** 
 238:hardware.c    **** void nvicDisableInterrupts() {
 533              		.loc 1 238 0
 534              		.cfi_startproc
 535              		@ args = 0, pretend = 0, frame = 0
 536              		@ frame_needed = 0, uses_anonymous_args = 0
 537              		@ link register save eliminated.
 538              	.LVL43:
 239:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 240:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 539              		.loc 1 240 0
 540 0000 074B     		ldr	r3, .L42
 541 0002 4FF0FF32 		mov	r2, #-1
 542 0006 C3F88020 		str	r2, [r3, #128]
 241:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 543              		.loc 1 241 0
 544 000a C3F88420 		str	r2, [r3, #132]
 242:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 545              		.loc 1 242 0
 546 000e C3F88021 		str	r2, [r3, #384]
 243:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 547              		.loc 1 243 0
 548 0012 C3F88421 		str	r2, [r3, #388]
 244:hardware.c    **** 
 245:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 549              		.loc 1 245 0
 550 0016 0422     		movs	r2, #4
 551 0018 43F8F02C 		str	r2, [r3, #-240]
 552 001c 7047     		bx	lr
 553              	.L43:
 554 001e 00BF     		.align	2
 555              	.L42:
 556 0020 00E100E0 		.word	-536813312
 557              		.cfi_endproc
 558              	.LFE11:
 560              		.section	.text.jumpToUser,"ax",%progbits
 561              		.align	1
 562              		.global	jumpToUser
 563              		.thumb
 564              		.thumb_func
 566              	jumpToUser:
 567              	.LFB9:
 177:hardware.c    **** void jumpToUser(u32 usrAddr) {
 568              		.loc 1 177 0
 569              		.cfi_startproc
 570              		@ args = 0, pretend = 0, frame = 0
 571              		@ frame_needed = 0, uses_anonymous_args = 0
 572              	.LVL44:
 573 0000 38B5     		push	{r3, r4, r5, lr}
 574              		.cfi_def_cfa_offset 16
 575              		.cfi_offset 3, -16
 576              		.cfi_offset 4, -12
 577              		.cfi_offset 5, -8
 578              		.cfi_offset 14, -4
 579              	.LBB7:
 580              	.LBB8:
 246:hardware.c    **** }
 247:hardware.c    **** 
 248:hardware.c    **** void systemHardReset(void) {
 249:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 250:hardware.c    **** 
 251:hardware.c    ****     /* Reset  */
 252:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 253:hardware.c    **** 
 254:hardware.c    ****     /*  should never get here */
 255:hardware.c    ****     while (1) {
 256:hardware.c    ****         asm volatile("nop");
 257:hardware.c    ****     }
 258:hardware.c    **** }
 259:hardware.c    **** 
 260:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 261:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 262:hardware.c    ****     rwmVal = FLASH_CR_PER;
 263:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 264:hardware.c    **** 
 265:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 266:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 267:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 268:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 269:hardware.c    **** 
 270:hardware.c    ****     /* todo: verify the page was erased */
 271:hardware.c    **** 
 272:hardware.c    ****     rwmVal = 0x00;
 273:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 274:hardware.c    **** 
 275:hardware.c    ****     return TRUE;
 276:hardware.c    **** }
 277:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 278:hardware.c    ****     while (n-- > 0) {
 279:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 280:hardware.c    ****             return FALSE;
 281:hardware.c    ****         }
 282:hardware.c    ****     }
 283:hardware.c    **** 
 284:hardware.c    ****     return TRUE;
 285:hardware.c    **** }
 286:hardware.c    **** 
 287:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 288:hardware.c    ****     vu16 *flashAddr = (vu16 *)addr;
 289:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 290:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 291:hardware.c    **** 
 292:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 293:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 294:hardware.c    **** 
 295:hardware.c    ****     /* apparently we need not write to FLASH_AR and can
 296:hardware.c    ****        simply do a native write of a half word */
 297:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 298:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 299:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 300:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 301:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 302:hardware.c    **** 
 303:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 304:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 305:hardware.c    **** 
 306:hardware.c    ****     /* verify the write */
 307:hardware.c    ****     if (*(vu32 *)addr != word) {
 308:hardware.c    ****         return FALSE;
 309:hardware.c    ****     }
 310:hardware.c    **** 
 311:hardware.c    ****     return TRUE;
 312:hardware.c    **** }
 313:hardware.c    **** 
 314:hardware.c    **** void flashLock() {
 315:hardware.c    ****     /* take down the HSI oscillator? it may be in use elsewhere */
 316:hardware.c    **** 
 317:hardware.c    ****     /* ensure all FPEC functions disabled and lock the FPEC */
 318:hardware.c    ****     SET_REG(FLASH_CR, 0x00000080);
 581              		.loc 1 318 0
 582 0002 094B     		ldr	r3, .L45
 583 0004 8022     		movs	r2, #128
 584              	.LBE8:
 585              	.LBE7:
 180:hardware.c    ****     u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 586              		.loc 1 180 0
 587 0006 4568     		ldr	r5, [r0, #4]
 588              	.LVL45:
 177:hardware.c    **** void jumpToUser(u32 usrAddr) {
 589              		.loc 1 177 0
 590 0008 0446     		mov	r4, r0
 591              	.LBB10:
 592              	.LBB9:
 593              		.loc 1 318 0
 594 000a 1A60     		str	r2, [r3]
 595              	.LBE9:
 596              	.LBE10:
 187:hardware.c    ****     usbDsbISR();
 597              		.loc 1 187 0
 598 000c FFF7FEFF 		bl	usbDsbISR
 599              	.LVL46:
 188:hardware.c    ****     nvicDisableInterrupts();
 600              		.loc 1 188 0
 601 0010 FFF7FEFF 		bl	nvicDisableInterrupts
 602              	.LVL47:
 191:hardware.c    **** 	usbDsbBus();
 603              		.loc 1 191 0
 604 0014 FFF7FEFF 		bl	usbDsbBus
 605              	.LVL48:
 195:hardware.c    ****     systemReset(); // resets clocks and periphs, not core regs
 606              		.loc 1 195 0
 607 0018 FFF7FEFF 		bl	systemReset
 608              	.LVL49:
 198:hardware.c    ****     __MSR_MSP(*(vu32 *) usrAddr);             /* set the users stack ptr */
 609              		.loc 1 198 0
 610 001c 2068     		ldr	r0, [r4]
 611 001e FFF7FEFF 		bl	__MSR_MSP
 612              	.LVL50:
 200:hardware.c    ****     usrMain();                                /* go! */
 613              		.loc 1 200 0
 614 0022 A847     		blx	r5
 615              	.LVL51:
 616 0024 38BD     		pop	{r3, r4, r5, pc}
 617              	.LVL52:
 618              	.L46:
 619 0026 00BF     		.align	2
 620              	.L45:
 621 0028 10200240 		.word	1073881104
 622              		.cfi_endproc
 623              	.LFE9:
 625              		.section	.text.systemHardReset,"ax",%progbits
 626              		.align	1
 627              		.global	systemHardReset
 628              		.thumb
 629              		.thumb_func
 631              	systemHardReset:
 632              	.LFB12:
 248:hardware.c    **** void systemHardReset(void) {
 633              		.loc 1 248 0
 634              		.cfi_startproc
 635              		@ args = 0, pretend = 0, frame = 0
 636              		@ frame_needed = 0, uses_anonymous_args = 0
 637              		@ link register save eliminated.
 638              	.LVL53:
 252:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 639              		.loc 1 252 0
 640 0000 024A     		ldr	r2, .L49
 641 0002 034B     		ldr	r3, .L49+4
 642 0004 DA60     		str	r2, [r3, #12]
 643              	.L48:
 256:hardware.c    ****         asm volatile("nop");
 644              		.loc 1 256 0 discriminator 1
 645              	@ 256 "hardware.c" 1
 646 0006 00BF     		nop
 647              	@ 0 "" 2
 648              		.thumb
 649 0008 FDE7     		b	.L48
 650              	.L50:
 651 000a 00BF     		.align	2
 652              	.L49:
 653 000c 0400FA05 		.word	100270084
 654 0010 00ED00E0 		.word	-536810240
 655              		.cfi_endproc
 656              	.LFE12:
 658              		.section	.text.flashErasePage,"ax",%progbits
 659              		.align	1
 660              		.global	flashErasePage
 661              		.thumb
 662              		.thumb_func
 664              	flashErasePage:
 665              	.LFB13:
 260:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 666              		.loc 1 260 0
 667              		.cfi_startproc
 668              		@ args = 0, pretend = 0, frame = 0
 669              		@ frame_needed = 0, uses_anonymous_args = 0
 670              	.LVL54:
 261:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 671              		.loc 1 261 0
 672 0000 0A4B     		ldr	r3, .L56
 260:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 673              		.loc 1 260 0
 674 0002 10B5     		push	{r4, lr}
 675              		.cfi_def_cfa_offset 8
 676              		.cfi_offset 4, -8
 677              		.cfi_offset 14, -4
 261:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 678              		.loc 1 261 0
 679 0004 1A68     		ldr	r2, [r3]
 680              	.LVL55:
 263:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 681              		.loc 1 263 0
 682 0006 0222     		movs	r2, #2
 683 0008 1A60     		str	r2, [r3]
 684              	.L53:
 265:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 685              		.loc 1 265 0 discriminator 1
 686 000a 094A     		ldr	r2, .L56+4
 687 000c 1168     		ldr	r1, [r2]
 688 000e 1446     		mov	r4, r2
 689 0010 11F0010F 		tst	r1, #1
 690 0014 F9D1     		bne	.L53
 266:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 691              		.loc 1 266 0
 692 0016 9060     		str	r0, [r2, #8]
 267:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 693              		.loc 1 267 0
 694 0018 4222     		movs	r2, #66
 695 001a 1A60     		str	r2, [r3]
 696              	.L55:
 268:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 697              		.loc 1 268 0 discriminator 1
 698 001c 2268     		ldr	r2, [r4]
 699 001e 12F00101 		ands	r1, r2, #1
 700 0022 FBD1     		bne	.L55
 701              	.LVL56:
 273:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 702              		.loc 1 273 0
 703 0024 1960     		str	r1, [r3]
 276:hardware.c    **** }
 704              		.loc 1 276 0
 705 0026 0120     		movs	r0, #1
 706              	.LVL57:
 707 0028 10BD     		pop	{r4, pc}
 708              	.L57:
 709 002a 00BF     		.align	2
 710              	.L56:
 711 002c 10200240 		.word	1073881104
 712 0030 0C200240 		.word	1073881100
 713              		.cfi_endproc
 714              	.LFE13:
 716              		.section	.text.flashErasePages,"ax",%progbits
 717              		.align	1
 718              		.global	flashErasePages
 719              		.thumb
 720              		.thumb_func
 722              	flashErasePages:
 723              	.LFB14:
 277:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 724              		.loc 1 277 0
 725              		.cfi_startproc
 726              		@ args = 0, pretend = 0, frame = 0
 727              		@ frame_needed = 0, uses_anonymous_args = 0
 728              	.LVL58:
 729 0000 0139     		subs	r1, r1, #1
 730              	.LVL59:
 731 0002 38B5     		push	{r3, r4, r5, lr}
 732              		.cfi_def_cfa_offset 16
 733              		.cfi_offset 3, -16
 734              		.cfi_offset 4, -12
 735              		.cfi_offset 5, -8
 736              		.cfi_offset 14, -4
 277:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 737              		.loc 1 277 0
 738 0004 0546     		mov	r5, r0
 739 0006 8CB2     		uxth	r4, r1
 740              	.LVL60:
 741              	.L59:
 278:hardware.c    ****     while (n-- > 0) {
 742              		.loc 1 278 0 discriminator 1
 743 0008 4FF6FF73 		movw	r3, #65535
 744 000c 9C42     		cmp	r4, r3
 745 000e 0AD0     		beq	.L65
 279:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 746              		.loc 1 279 0
 747 0010 064B     		ldr	r3, .L66
 748 0012 1868     		ldr	r0, [r3]
 749 0014 00FB0450 		mla	r0, r0, r4, r5
 750 0018 FFF7FEFF 		bl	flashErasePage
 751              	.LVL61:
 752 001c 013C     		subs	r4, r4, #1
 753              	.LVL62:
 754 001e A4B2     		uxth	r4, r4
 755              	.LVL63:
 756 0020 0028     		cmp	r0, #0
 757 0022 F1D1     		bne	.L59
 758 0024 00E0     		b	.L60
 759              	.LVL64:
 760              	.L65:
 284:hardware.c    ****     return TRUE;
 761              		.loc 1 284 0
 762 0026 0120     		movs	r0, #1
 763              	.LVL65:
 764              	.L60:
 285:hardware.c    **** }
 765              		.loc 1 285 0
 766 0028 38BD     		pop	{r3, r4, r5, pc}
 767              	.LVL66:
 768              	.L67:
 769 002a 00BF     		.align	2
 770              	.L66:
 771 002c 00000000 		.word	wTransferSize
 772              		.cfi_endproc
 773              	.LFE14:
 775              		.section	.text.flashWriteWord,"ax",%progbits
 776              		.align	1
 777              		.global	flashWriteWord
 778              		.thumb
 779              		.thumb_func
 781              	flashWriteWord:
 782              	.LFB15:
 287:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 783              		.loc 1 287 0
 784              		.cfi_startproc
 785              		@ args = 0, pretend = 0, frame = 8
 786              		@ frame_needed = 0, uses_anonymous_args = 0
 787              	.LVL67:
 788 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 789              		.cfi_def_cfa_offset 24
 790              		.cfi_offset 0, -24
 791              		.cfi_offset 1, -20
 792              		.cfi_offset 2, -16
 793              		.cfi_offset 4, -12
 794              		.cfi_offset 5, -8
 795              		.cfi_offset 14, -4
 289:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 796              		.loc 1 289 0
 797 0002 8BB2     		uxth	r3, r1
 798 0004 0093     		str	r3, [sp]
 290:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 799              		.loc 1 290 0
 800 0006 0B0C     		lsrs	r3, r1, #16
 801 0008 0193     		str	r3, [sp, #4]
 292:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 802              		.loc 1 292 0
 803 000a 0E4B     		ldr	r3, .L75
 293:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 804              		.loc 1 293 0
 805 000c 0122     		movs	r2, #1
 292:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 806              		.loc 1 292 0
 807 000e 1C68     		ldr	r4, [r3]
 808              	.LVL68:
 293:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 809              		.loc 1 293 0
 810 0010 1A60     		str	r2, [r3]
 811              	.L70:
 297:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 812              		.loc 1 297 0 discriminator 1
 813 0012 0D4A     		ldr	r2, .L75+4
 814 0014 1568     		ldr	r5, [r2]
 815 0016 ED07     		lsls	r5, r5, #31
 816 0018 FBD4     		bmi	.L70
 298:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 817              		.loc 1 298 0
 818 001a 019D     		ldr	r5, [sp, #4]
 819 001c ADB2     		uxth	r5, r5
 820 001e 4580     		strh	r5, [r0, #2]	@ movhi
 821              	.L72:
 299:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 822              		.loc 1 299 0 discriminator 1
 823 0020 1568     		ldr	r5, [r2]
 824 0022 ED07     		lsls	r5, r5, #31
 825 0024 FCD4     		bmi	.L72
 300:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 826              		.loc 1 300 0
 827 0026 009D     		ldr	r5, [sp]
 828 0028 ADB2     		uxth	r5, r5
 829 002a 0580     		strh	r5, [r0]	@ movhi
 830              	.L74:
 301:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 831              		.loc 1 301 0 discriminator 1
 832 002c 1568     		ldr	r5, [r2]
 833 002e ED07     		lsls	r5, r5, #31
 834 0030 FCD4     		bmi	.L74
 303:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 835              		.loc 1 303 0
 836 0032 24F00102 		bic	r2, r4, #1
 837              	.LVL69:
 304:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 838              		.loc 1 304 0
 839 0036 1A60     		str	r2, [r3]
 307:hardware.c    ****     if (*(vu32 *)addr != word) {
 840              		.loc 1 307 0
 841 0038 0068     		ldr	r0, [r0]
 842              	.LVL70:
 312:hardware.c    **** }
 843              		.loc 1 312 0
 844 003a 431A     		subs	r3, r0, r1
 845 003c 5842     		rsbs	r0, r3, #0
 846 003e 5841     		adcs	r0, r0, r3
 847 0040 03B0     		add	sp, sp, #12
 848              		@ sp needed
 849 0042 30BD     		pop	{r4, r5, pc}
 850              	.L76:
 851              		.align	2
 852              	.L75:
 853 0044 10200240 		.word	1073881104
 854 0048 0C200240 		.word	1073881100
 855              		.cfi_endproc
 856              	.LFE15:
 858              		.section	.text.flashLock,"ax",%progbits
 859              		.align	1
 860              		.global	flashLock
 861              		.thumb
 862              		.thumb_func
 864              	flashLock:
 865              	.LFB16:
 314:hardware.c    **** void flashLock() {
 866              		.loc 1 314 0
 867              		.cfi_startproc
 868              		@ args = 0, pretend = 0, frame = 0
 869              		@ frame_needed = 0, uses_anonymous_args = 0
 870              		@ link register save eliminated.
 871              		.loc 1 318 0
 872 0000 014B     		ldr	r3, .L78
 873 0002 8022     		movs	r2, #128
 874 0004 1A60     		str	r2, [r3]
 875 0006 7047     		bx	lr
 876              	.L79:
 877              		.align	2
 878              	.L78:
 879 0008 10200240 		.word	1073881104
 880              		.cfi_endproc
 881              	.LFE16:
 883              		.section	.text.flashUnlock,"ax",%progbits
 884              		.align	1
 885              		.global	flashUnlock
 886              		.thumb
 887              		.thumb_func
 889              	flashUnlock:
 890              	.LFB17:
 319:hardware.c    **** }
 320:hardware.c    **** 
 321:hardware.c    **** void flashUnlock() {
 891              		.loc 1 321 0
 892              		.cfi_startproc
 893              		@ args = 0, pretend = 0, frame = 0
 894              		@ frame_needed = 0, uses_anonymous_args = 0
 895              		@ link register save eliminated.
 322:hardware.c    ****     /* unlock the flash */
 323:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY1);
 896              		.loc 1 323 0
 897 0000 034B     		ldr	r3, .L81
 898 0002 044A     		ldr	r2, .L81+4
 899 0004 1A60     		str	r2, [r3]
 324:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY2);
 900              		.loc 1 324 0
 901 0006 02F18832 		add	r2, r2, #-2004318072
 902 000a 1A60     		str	r2, [r3]
 903 000c 7047     		bx	lr
 904              	.L82:
 905 000e 00BF     		.align	2
 906              	.L81:
 907 0010 04200240 		.word	1073881092
 908 0014 23016745 		.word	1164378403
 909              		.cfi_endproc
 910              	.LFE17:
 912              		.section	.text.crMask,"ax",%progbits
 913              		.align	1
 914              		.global	crMask
 915              		.thumb
 916              		.thumb_func
 918              	crMask:
 919              	.LFB18:
 325:hardware.c    **** }
 326:hardware.c    **** 
 327:hardware.c    **** 
 328:hardware.c    **** // Used to create the control register masking pattern, when setting control register mode.
 329:hardware.c    **** unsigned int crMask(int pin)
 330:hardware.c    **** {
 920              		.loc 1 330 0
 921              		.cfi_startproc
 922              		@ args = 0, pretend = 0, frame = 0
 923              		@ frame_needed = 0, uses_anonymous_args = 0
 924              		@ link register save eliminated.
 925              	.LVL71:
 331:hardware.c    **** 	unsigned int mask;
 332:hardware.c    **** 	if (pin>=8)
 926              		.loc 1 332 0
 927 0000 0728     		cmp	r0, #7
 333:hardware.c    **** 	{
 334:hardware.c    **** 		pin-=8;
 928              		.loc 1 334 0
 929 0002 C8BF     		it	gt
 930 0004 0838     		subgt	r0, r0, #8
 931              	.LVL72:
 335:hardware.c    **** 	}
 336:hardware.c    **** 	mask = 0x0F << (pin<<2);
 932              		.loc 1 336 0
 933 0006 0F23     		movs	r3, #15
 934 0008 8000     		lsls	r0, r0, #2
 935              	.LVL73:
 936 000a 03FA00F0 		lsl	r0, r3, r0
 937              	.LVL74:
 337:hardware.c    **** 	return ~mask;
 338:hardware.c    **** }	
 938              		.loc 1 338 0
 939 000e C043     		mvns	r0, r0
 940              	.LVL75:
 941 0010 7047     		bx	lr
 942              		.cfi_endproc
 943              	.LFE18:
 945              		.section	.text.getFlashEnd,"ax",%progbits
 946              		.align	1
 947              		.global	getFlashEnd
 948              		.thumb
 949              		.thumb_func
 951              	getFlashEnd:
 952              	.LFB19:
 339:hardware.c    **** 
 340:hardware.c    **** #define FLASH_SIZE_REG 0x1FFFF7E0
 341:hardware.c    **** int getFlashEnd(void)
 342:hardware.c    **** {
 953              		.loc 1 342 0
 954              		.cfi_startproc
 955              		@ args = 0, pretend = 0, frame = 0
 956              		@ frame_needed = 0, uses_anonymous_args = 0
 957              		@ link register save eliminated.
 958              	.LVL76:
 343:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 344:hardware.c    **** 	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
 959              		.loc 1 344 0
 960 0000 024B     		ldr	r3, .L86
 961 0002 1888     		ldrh	r0, [r3]
 962 0004 00F50030 		add	r0, r0, #131072
 345:hardware.c    **** }
 963              		.loc 1 345 0
 964 0008 8002     		lsls	r0, r0, #10
 965 000a 7047     		bx	lr
 966              	.L87:
 967              		.align	2
 968              	.L86:
 969 000c E0F7FF1F 		.word	536868832
 970              		.cfi_endproc
 971              	.LFE19:
 973              		.section	.text.getFlashPageSize,"ax",%progbits
 974              		.align	1
 975              		.global	getFlashPageSize
 976              		.thumb
 977              		.thumb_func
 979              	getFlashPageSize:
 980              	.LFB20:
 346:hardware.c    **** 
 347:hardware.c    **** int getFlashPageSize(void)
 348:hardware.c    **** {
 981              		.loc 1 348 0
 982              		.cfi_startproc
 983              		@ args = 0, pretend = 0, frame = 0
 984              		@ frame_needed = 0, uses_anonymous_args = 0
 985              		@ link register save eliminated.
 986              	.LVL77:
 349:hardware.c    **** 
 350:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 351:hardware.c    **** 	if ((*flashSize & 0xffff) > 128)
 987              		.loc 1 351 0
 988 0000 044B     		ldr	r3, .L91
 989 0002 1B88     		ldrh	r3, [r3]
 352:hardware.c    **** 	{
 353:hardware.c    **** 		return 0x800;
 990              		.loc 1 353 0
 991 0004 812B     		cmp	r3, #129
 354:hardware.c    **** 	}
 355:hardware.c    **** 	else
 356:hardware.c    **** 	{
 357:hardware.c    **** 		return 0x400;
 358:hardware.c    **** 	}
 359:hardware.c    **** }
 992              		.loc 1 359 0
 993 0006 34BF     		ite	cc
 994 0008 4FF48060 		movcc	r0, #1024
 995 000c 4FF40060 		movcs	r0, #2048
 996 0010 7047     		bx	lr
 997              	.L92:
 998 0012 00BF     		.align	2
 999              	.L91:
 1000 0014 E0F7FF1F 		.word	536868832
 1001              		.cfi_endproc
 1002              	.LFE20:
 1004              		.comm	wTransferSize,4,4
 1005              		.text
 1006              	.Letext0:
 1007              		.file 2 "./stm32_lib/stm32f10x_type.h"
 1008              		.file 3 "hardware.h"
 1009              		.file 4 "usb.h"
 1010              		.file 5 "./stm32_lib/cortexm3_macro.h"
DEFINED SYMBOLS
                            *ABS*:00000000 hardware.c
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:19     .text.gpio_write_bit:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:24     .text.gpio_write_bit:00000000 gpio_write_bit
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:51     .text.readPin:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:56     .text.readPin:00000000 readPin
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:80     .text.readButtonState:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:85     .text.readButtonState:00000000 readButtonState
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:100    .text.strobePin:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:105    .text.strobePin:00000000 strobePin
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:196    .text.systemReset:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:201    .text.systemReset:00000000 systemReset
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:242    .text.systemReset:00000038 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:250    .text.setupCLK:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:255    .text.setupCLK:00000000 setupCLK
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:313    .text.setupCLK:00000058 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:319    .text.setupLEDAndButton:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:324    .text.setupLEDAndButton:00000000 setupLEDAndButton
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:342    .text.setupLEDAndButton:00000010 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:347    .text.setupFLASH:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:352    .text.setupFLASH:00000000 setupFLASH
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:385    .text.setupFLASH:00000018 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:390    .text.checkUserCode:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:395    .text.checkUserCode:00000000 checkUserCode
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:419    .text.checkUserCode:00000010 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:424    .text.nvicInit:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:429    .text.nvicInit:00000000 nvicInit
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:520    .text.nvicInit:00000064 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:526    .text.nvicDisableInterrupts:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:531    .text.nvicDisableInterrupts:00000000 nvicDisableInterrupts
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:556    .text.nvicDisableInterrupts:00000020 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:561    .text.jumpToUser:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:566    .text.jumpToUser:00000000 jumpToUser
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:621    .text.jumpToUser:00000028 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:626    .text.systemHardReset:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:631    .text.systemHardReset:00000000 systemHardReset
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:653    .text.systemHardReset:0000000c $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:659    .text.flashErasePage:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:664    .text.flashErasePage:00000000 flashErasePage
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:711    .text.flashErasePage:0000002c $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:717    .text.flashErasePages:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:722    .text.flashErasePages:00000000 flashErasePages
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:771    .text.flashErasePages:0000002c $d
                            *COM*:00000004 wTransferSize
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:776    .text.flashWriteWord:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:781    .text.flashWriteWord:00000000 flashWriteWord
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:853    .text.flashWriteWord:00000044 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:859    .text.flashLock:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:864    .text.flashLock:00000000 flashLock
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:879    .text.flashLock:00000008 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:884    .text.flashUnlock:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:889    .text.flashUnlock:00000000 flashUnlock
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:907    .text.flashUnlock:00000010 $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:913    .text.crMask:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:918    .text.crMask:00000000 crMask
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:946    .text.getFlashEnd:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:951    .text.getFlashEnd:00000000 getFlashEnd
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:969    .text.getFlashEnd:0000000c $d
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:974    .text.getFlashPageSize:00000000 $t
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:979    .text.getFlashPageSize:00000000 getFlashPageSize
C:\Users\rclark\AppData\Local\Temp\cciPLxR6.s:1000   .text.getFlashPageSize:00000014 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
usbDsbISR
usbDsbBus
__MSR_MSP
