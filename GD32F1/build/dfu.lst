   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"dfu.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.dfuInit,"ax",%progbits
  19              		.align	1
  20              		.global	dfuInit
  21              		.thumb
  22              		.thumb_func
  24              	dfuInit:
  25              	.LFB0:
  26              		.file 1 "dfu.c"
   1:dfu.c         **** /* *****************************************************************************
   2:dfu.c         ****  * The MIT License
   3:dfu.c         ****  *
   4:dfu.c         ****  * Copyright (c) 2010 LeafLabs LLC.
   5:dfu.c         ****  *
   6:dfu.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:dfu.c         ****  * of this software and associated documentation files (the "Software"), to deal
   8:dfu.c         ****  * in the Software without restriction, including without limitation the rights
   9:dfu.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:dfu.c         ****  * copies of the Software, and to permit persons to whom the Software is
  11:dfu.c         ****  * furnished to do so, subject to the following conditions:
  12:dfu.c         ****  *
  13:dfu.c         ****  * The above copyright notice and this permission notice shall be included in
  14:dfu.c         ****  * all copies or substantial portions of the Software.
  15:dfu.c         ****  *
  16:dfu.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:dfu.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:dfu.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:dfu.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:dfu.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:dfu.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:dfu.c         ****  * THE SOFTWARE.
  23:dfu.c         ****  * ****************************************************************************/
  24:dfu.c         **** 
  25:dfu.c         **** /**
  26:dfu.c         ****  *  @file dfu.c
  27:dfu.c         ****  *
  28:dfu.c         ****  *  @brief The principle dfu state machine as well as the data
  29:dfu.c         ****  *  transfer callbacks accessed by the usb library
  30:dfu.c         ****  *
  31:dfu.c         ****  *
  32:dfu.c         ****  */
  33:dfu.c         **** #include "hardware.h"
  34:dfu.c         **** #include "dfu.h"
  35:dfu.c         **** #include "usb.h"
  36:dfu.c         **** 
  37:dfu.c         **** /* DFU globals */
  38:dfu.c         **** static volatile u32 userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  39:dfu.c         **** static volatile u32 userAppEnd = RAM_END;
  40:dfu.c         **** static volatile DFUStatus dfuAppStatus;       /* includes state */
  41:dfu.c         **** volatile dfuUploadTypes_t userUploadType = DFU_UPLOAD_NONE;
  42:dfu.c         **** volatile bool dfuBusy = FALSE;
  43:dfu.c         **** 
  44:dfu.c         **** 
  45:dfu.c         **** //static volatile u8 recvBuffer[wTransferSize] __attribute__((aligned(4)));
  46:dfu.c         **** static volatile u8 recvBuffer[LARGEST_FLASH_PAGE_SIZE] __attribute__((aligned(4)));
  47:dfu.c         **** 
  48:dfu.c         **** static volatile u32 userFirmwareLen = 0;
  49:dfu.c         **** static volatile u16 thisBlockLen = 0;
  50:dfu.c         **** static volatile u16 uploadBlockLen = 0;
  51:dfu.c         **** 
  52:dfu.c         **** 
  53:dfu.c         **** volatile PLOT code_copy_lock;
  54:dfu.c         **** 
  55:dfu.c         **** /* todo: force dfu globals to be singleton to avoid re-inits? */
  56:dfu.c         **** void dfuInit(void) {
  27              		.loc 1 56 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  57:dfu.c         ****     dfuAppStatus.bStatus = OK;
  32              		.loc 1 57 0
  33 0000 0D4A     		ldr	r2, .L2
  34 0002 0023     		movs	r3, #0
  58:dfu.c         ****     dfuAppStatus.bwPollTimeout0 = 0x00;
  59:dfu.c         ****     dfuAppStatus.bwPollTimeout1 = 0x00;
  60:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  61:dfu.c         ****     dfuAppStatus.bState = dfuIDLE;
  35              		.loc 1 61 0
  36 0004 0221     		movs	r1, #2
  57:dfu.c         ****     dfuAppStatus.bStatus = OK;
  37              		.loc 1 57 0
  38 0006 1370     		strb	r3, [r2]
  58:dfu.c         ****     dfuAppStatus.bwPollTimeout0 = 0x00;
  39              		.loc 1 58 0
  40 0008 5370     		strb	r3, [r2, #1]
  59:dfu.c         ****     dfuAppStatus.bwPollTimeout1 = 0x00;
  41              		.loc 1 59 0
  42 000a 9370     		strb	r3, [r2, #2]
  60:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  43              		.loc 1 60 0
  44 000c D370     		strb	r3, [r2, #3]
  45              		.loc 1 61 0
  46 000e 1171     		strb	r1, [r2, #4]
  62:dfu.c         ****     dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
  47              		.loc 1 62 0
  48 0010 5371     		strb	r3, [r2, #5]
  63:dfu.c         ****     userFirmwareLen = 0;
  49              		.loc 1 63 0
  50 0012 0A4A     		ldr	r2, .L2+4
  64:dfu.c         ****     thisBlockLen = 0;;
  65:dfu.c         ****     userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  51              		.loc 1 65 0
  52 0014 0A49     		ldr	r1, .L2+8
  63:dfu.c         ****     userFirmwareLen = 0;
  53              		.loc 1 63 0
  54 0016 1360     		str	r3, [r2]
  64:dfu.c         ****     thisBlockLen = 0;;
  55              		.loc 1 64 0
  56 0018 0A4A     		ldr	r2, .L2+12
  57 001a 1380     		strh	r3, [r2]	@ movhi
  58              		.loc 1 65 0
  59 001c 0A4A     		ldr	r2, .L2+16
  60 001e 1160     		str	r1, [r2]
  66:dfu.c         ****     userAppEnd = RAM_END;
  61              		.loc 1 66 0
  62 0020 0A4A     		ldr	r2, .L2+20
  63 0022 01F58841 		add	r1, r1, #17408
  64 0026 1160     		str	r1, [r2]
  67:dfu.c         ****     userUploadType=DFU_UPLOAD_NONE;
  65              		.loc 1 67 0
  66 0028 094A     		ldr	r2, .L2+24
  68:dfu.c         ****     code_copy_lock = WAIT;
  67              		.loc 1 68 0
  68 002a 0321     		movs	r1, #3
  67:dfu.c         ****     userUploadType=DFU_UPLOAD_NONE;
  69              		.loc 1 67 0
  70 002c 1370     		strb	r3, [r2]
  71              		.loc 1 68 0
  72 002e 094A     		ldr	r2, .L2+28
  73 0030 1170     		strb	r1, [r2]
  69:dfu.c         ****     dfuBusy = FALSE;
  74              		.loc 1 69 0
  75 0032 094A     		ldr	r2, .L2+32
  76 0034 1370     		strb	r3, [r2]
  77 0036 7047     		bx	lr
  78              	.L3:
  79              		.align	2
  80              	.L2:
  81 0038 00000000 		.word	.LANCHOR0
  82 003c 00000000 		.word	.LANCHOR1
  83 0040 000C0020 		.word	536873984
  84 0044 00000000 		.word	.LANCHOR2
  85 0048 00000000 		.word	.LANCHOR3
  86 004c 00000000 		.word	.LANCHOR4
  87 0050 00000000 		.word	.LANCHOR5
  88 0054 00000000 		.word	code_copy_lock
  89 0058 00000000 		.word	.LANCHOR6
  90              		.cfi_endproc
  91              	.LFE0:
  93              		.section	.text.dfuUpdateByReset,"ax",%progbits
  94              		.align	1
  95              		.global	dfuUpdateByReset
  96              		.thumb
  97              		.thumb_func
  99              	dfuUpdateByReset:
 100              	.LFB2:
  70:dfu.c         **** }
  71:dfu.c         **** 
  72:dfu.c         **** 
  73:dfu.c         **** 
  74:dfu.c         **** 
  75:dfu.c         **** bool dfuUpdateByRequest(void) {
  76:dfu.c         ****     /* were using the global pInformation struct from usb_lib here,
  77:dfu.c         ****        see comment in maple_dfu.h around DFUEvent struct */
  78:dfu.c         ****     dfuBusy = TRUE;
  79:dfu.c         **** 	
  80:dfu.c         **** 
  81:dfu.c         **** 
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
  83:dfu.c         ****     dfuAppStatus.bStatus = OK;
  84:dfu.c         ****     /* often leaner to nest if's then embed a switch/case */
  85:dfu.c         ****     if (startState == dfuIDLE)  {
  86:dfu.c         ****         /*  device running inside DFU mode */
  87:dfu.c         ****         dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
  88:dfu.c         **** 
  89:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
  90:dfu.c         **** 
  91:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
  92:dfu.c         ****                 userFirmwareLen = 0;
  93:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
  94:dfu.c         **** 				switch(pInformation->Current_AlternateSetting)
  95:dfu.c         **** 				{
  96:dfu.c         **** 					/*
  97:dfu.c         **** 					Roger Clark. removed upload to RAM option
  98:dfu.c         **** 					case 0:
  99:dfu.c         **** 					    userAppAddr = USER_CODE_RAM;
 100:dfu.c         **** 						userUploadType = DFU_UPLOAD_RAM;
 101:dfu.c         **** 						break;
 102:dfu.c         **** 						*/
 103:dfu.c         **** 					case 1:
 104:dfu.c         **** 					    userAppAddr = USER_CODE_FLASH0X8005000;
 105:dfu.c         **** 						userUploadType = DFU_UPLOAD_FLASH_0X8005000;
 106:dfu.c         **** 						
 107:dfu.c         **** 						/* make sure the flash is setup properly, unlock it */
 108:dfu.c         **** 						setupFLASH();
 109:dfu.c         **** 						flashUnlock();
 110:dfu.c         **** 						// Clear lower memory so that we can check on cold boot, whether the last upload was to 0x800
 111:dfu.c         **** 						flashErasePage((u32)USER_CODE_FLASH0X8002000);
 112:dfu.c         **** 						break;
 113:dfu.c         **** 					case 2:
 114:dfu.c         **** 						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
 115:dfu.c         **** 						userAppAddr = USER_CODE_FLASH0X8002000;
 116:dfu.c         **** 						/* make sure the flash is setup properly, unlock it */
 117:dfu.c         **** 						setupFLASH();
 118:dfu.c         **** 						flashUnlock();
 119:dfu.c         **** 						break;
 120:dfu.c         **** 					default:
 121:dfu.c         **** 					// Roger Clark. Report error 
 122:dfu.c         **** 						dfuAppStatus.bState  = dfuERROR;
 123:dfu.c         **** 						dfuAppStatus.bStatus = errWRITE;
 124:dfu.c         **** 						break;
 125:dfu.c         **** 				}
 126:dfu.c         ****             } else {
 127:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 128:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 129:dfu.c         ****             }
 130:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_UPLOAD) {
 131:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 132:dfu.c         ****             /* record length of first block for calculating target
 133:dfu.c         ****                address from wValue in consecutive blocks */
 134:dfu.c         ****             uploadBlockLen = pInformation->USBwLengths.w;
 135:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 136:dfu.c         ****             /* calculate where the data should be copied from */
 137:dfu.c         ****             userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 138:dfu.c         **** 			switch(pInformation->Current_AlternateSetting)
 139:dfu.c         **** 			{
 140:dfu.c         **** 			/*
 141:dfu.c         **** 				case 0:
 142:dfu.c         **** 					userAppAddr = USER_CODE_RAM;
 143:dfu.c         **** 					userAppEnd = RAM_END;
 144:dfu.c         **** 					*/
 145:dfu.c         **** 				case 1:
 146:dfu.c         **** 				    userAppAddr = USER_CODE_FLASH0X8005000;
 147:dfu.c         **** 					userAppEnd = getFlashEnd();
 148:dfu.c         **** 					break;
 149:dfu.c         **** 				case 2: 
 150:dfu.c         **** 				    userAppAddr = USER_CODE_FLASH0X8002000;
 151:dfu.c         **** 					userAppEnd = getFlashEnd();
 152:dfu.c         **** 					break;
 153:dfu.c         **** 				default:
 154:dfu.c         **** 				// Roger Clark. 
 155:dfu.c         **** 				// Changed this to report error that its unable to write to this memory
 156:dfu.c         **** 				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see abo
 157:dfu.c         **** 					dfuAppStatus.bState  = dfuERROR;
 158:dfu.c         **** 					dfuAppStatus.bStatus = errWRITE;
 159:dfu.c         **** 					break;					
 160:dfu.c         **** 			}
 161:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 162:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 163:dfu.c         ****             dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
 164:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 165:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 166:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 167:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 168:dfu.c         ****         } else {
 169:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 170:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 171:dfu.c         ****         }
 172:dfu.c         **** 
 173:dfu.c         ****     } else if (startState == dfuDNLOAD_SYNC)         {
 174:dfu.c         ****         /* device received block, waiting for DFU_GETSTATUS request */
 175:dfu.c         **** 
 176:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 177:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 178:dfu.c         **** 			
 179:dfu.c         **** 			/* Roger Clark. Commented out code associated with RAM upload
 180:dfu.c         **** 			
 181:dfu.c         ****             if (userUploadType == DFU_UPLOAD_RAM) 
 182:dfu.c         **** 			{
 183:dfu.c         ****                 if (code_copy_lock == WAIT) {
 184:dfu.c         ****                     code_copy_lock = BEGINNING;
 185:dfu.c         ****                     dfuAppStatus.bwPollTimeout0 = 0x20; // 32 ms 
 186:dfu.c         ****                     dfuAppStatus.bwPollTimeout1 = 0x00;
 187:dfu.c         ****                     dfuAppStatus.bState = dfuDNBUSY;
 188:dfu.c         **** 
 189:dfu.c         ****                 } else if (code_copy_lock == BEGINNING) {
 190:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_SYNC;
 191:dfu.c         **** 
 192:dfu.c         ****                 } else if (code_copy_lock == MIDDLE) {
 193:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_SYNC;
 194:dfu.c         **** 
 195:dfu.c         ****                 } else if (code_copy_lock == END) {
 196:dfu.c         ****                     dfuAppStatus.bwPollTimeout0 = 0x00;
 197:dfu.c         ****                     code_copy_lock = WAIT;
 198:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_IDLE;
 199:dfu.c         ****                 }
 200:dfu.c         **** 
 201:dfu.c         ****             } 
 202:dfu.c         **** 			else 
 203:dfu.c         **** 			*/
 204:dfu.c         **** 			{
 205:dfu.c         ****                 dfuAppStatus.bState = dfuDNLOAD_IDLE;
 206:dfu.c         ****                 dfuCopyBufferToExec();
 207:dfu.c         ****             }
 208:dfu.c         **** 
 209:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 210:dfu.c         ****             dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 211:dfu.c         ****         } else {
 212:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 213:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 214:dfu.c         ****         }
 215:dfu.c         **** 
 216:dfu.c         ****     } else if (startState == dfuDNBUSY)              {
 217:dfu.c         ****         /* if were actually done writing, goto sync, else stay busy */
 218:dfu.c         ****         if (code_copy_lock == END) {
 219:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 220:dfu.c         ****             code_copy_lock = WAIT;
 221:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 222:dfu.c         ****         } else {
 223:dfu.c         ****             dfuAppStatus.bState = dfuDNBUSY;
 224:dfu.c         ****         }
 225:dfu.c         **** 
 226:dfu.c         ****     } else if (startState == dfuDNLOAD_IDLE)         {
 227:dfu.c         ****         /* device is expecting dfu_dnload requests */
 228:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
 229:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 230:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 231:dfu.c         ****             } else {
 232:dfu.c         ****                 /* todo, support "disagreement" if device expects more data than this */
 233:dfu.c         ****                 dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 234:dfu.c         **** 
 235:dfu.c         ****                 /* relock the flash */
 236:dfu.c         ****                 flashLock();
 237:dfu.c         ****             }
 238:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 239:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 240:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 241:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 242:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 243:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 244:dfu.c         ****         } else {
 245:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 246:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 247:dfu.c         ****         }
 248:dfu.c         **** 
 249:dfu.c         ****     } else if (startState == dfuMANIFEST_SYNC)       {
 250:dfu.c         ****         /* device has received last block, waiting DFU_GETSTATUS request */
 251:dfu.c         **** 
 252:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 253:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 254:dfu.c         ****             dfuAppStatus.bStatus = OK;
 255:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 256:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 257:dfu.c         ****         } else {
 258:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 259:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 260:dfu.c         ****         }
 261:dfu.c         **** 
 262:dfu.c         ****     } else if (startState == dfuMANIFEST)            {
 263:dfu.c         ****         /* device is in manifestation phase */
 264:dfu.c         **** 
 265:dfu.c         ****         /* should never receive request while in manifest! */
 266:dfu.c         ****         dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 267:dfu.c         ****         dfuAppStatus.bStatus = OK;
 268:dfu.c         **** 
 269:dfu.c         ****     } else if (startState == dfuMANIFEST_WAIT_RESET) {
 270:dfu.c         ****         /* device has programmed new firmware but needs external
 271:dfu.c         ****            usb reset or power on reset to run the new code */
 272:dfu.c         **** 
 273:dfu.c         ****         /* consider timing out and self-resetting */
 274:dfu.c         ****         dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 275:dfu.c         **** 
 276:dfu.c         ****     } else if (startState == dfuUPLOAD_IDLE)         {
 277:dfu.c         ****         /* device expecting further dfu_upload requests */
 278:dfu.c         **** 
 279:dfu.c         ****         if (pInformation->USBbRequest == DFU_UPLOAD) {
 280:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 281:dfu.c         ****                 /* check that this is not the last possible block */
 282:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 283:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 284:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 285:dfu.c         ****                     dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 286:dfu.c         ****                 } else {
 287:dfu.c         ****                     /* if above comparison was just equal, thisBlockLen becomes zero
 288:dfu.c         ****                     next time when USBWValue has been increased by one */
 289:dfu.c         ****                     thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
 290:dfu.c         ****                     /* check for overflow due to USBwValue out of range */
 291:dfu.c         ****                     if (thisBlockLen >= pInformation->USBwLengths.w) {
 292:dfu.c         ****                         thisBlockLen = 0;
 293:dfu.c         ****                     }
 294:dfu.c         ****                     dfuAppStatus.bState  = dfuIDLE;
 295:dfu.c         ****                 }
 296:dfu.c         ****             } else {
 297:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 298:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 299:dfu.c         ****             }
 300:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 301:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 302:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 303:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 304:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 305:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 306:dfu.c         ****         } else {
 307:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 308:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 309:dfu.c         ****         }
 310:dfu.c         **** 
 311:dfu.c         **** 
 312:dfu.c         ****     } else if (startState == dfuERROR)               {
 313:dfu.c         ****         /* status is in error, awaiting DFU_CLRSTATUS request */
 314:dfu.c         **** 
 315:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 316:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 317:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 318:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 319:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 320:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
 321:dfu.c         ****             /* todo handle any cleanup we need here */
 322:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 323:dfu.c         ****             dfuAppStatus.bStatus = OK;
 324:dfu.c         ****         } else {
 325:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 326:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 327:dfu.c         ****         }
 328:dfu.c         **** 
 329:dfu.c         ****     } else {
 330:dfu.c         ****         /* some kind of error... */
 331:dfu.c         ****         dfuAppStatus.bState  = dfuERROR;
 332:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 333:dfu.c         ****     }
 334:dfu.c         **** 
 335:dfu.c         ****     if (dfuAppStatus.bStatus == OK) {
 336:dfu.c         ****         return TRUE;
 337:dfu.c         ****     } else {
 338:dfu.c         ****         return FALSE;
 339:dfu.c         ****     }
 340:dfu.c         **** }
 341:dfu.c         **** 
 342:dfu.c         **** void dfuUpdateByReset(void) {
 101              		.loc 1 342 0
 102              		.cfi_startproc
 103              		@ args = 0, pretend = 0, frame = 0
 104              		@ frame_needed = 0, uses_anonymous_args = 0
 105 0000 08B5     		push	{r3, lr}
 106              		.cfi_def_cfa_offset 8
 107              		.cfi_offset 3, -8
 108              		.cfi_offset 14, -4
 343:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 109              		.loc 1 343 0
 110 0002 0E4B     		ldr	r3, .L8
 344:dfu.c         ****     userFirmwareLen = 0;
 111              		.loc 1 344 0
 112 0004 0E48     		ldr	r0, .L8+4
 343:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 113              		.loc 1 343 0
 114 0006 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 115              		.loc 1 344 0
 116 0008 0022     		movs	r2, #0
 343:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 117              		.loc 1 343 0
 118 000a C9B2     		uxtb	r1, r1
 119              	.LVL0:
 345:dfu.c         **** 
 346:dfu.c         ****     if (startState == appDETACH) {
 120              		.loc 1 346 0
 121 000c 0129     		cmp	r1, #1
 344:dfu.c         ****     userFirmwareLen = 0;
 122              		.loc 1 344 0
 123 000e 0260     		str	r2, [r0]
 124              		.loc 1 346 0
 125 0010 08D1     		bne	.L5
 347:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 126              		.loc 1 347 0
 127 0012 0221     		movs	r1, #2
 128              	.LVL1:
 129 0014 1971     		strb	r1, [r3, #4]
 348:dfu.c         ****         dfuAppStatus.bStatus = OK;
 130              		.loc 1 348 0
 131 0016 1A70     		strb	r2, [r3]
 349:dfu.c         **** 
 350:dfu.c         ****         nvicDisableInterrupts();
 132              		.loc 1 350 0
 133 0018 FFF7FEFF 		bl	nvicDisableInterrupts
 134              	.LVL2:
 351:dfu.c         ****         usbEnbISR();
 352:dfu.c         **** 
 353:dfu.c         ****     } else if (startState == appIDLE || startState == dfuIDLE) {
 354:dfu.c         ****         /* do nothing...might be normal usb bus activity */
 355:dfu.c         ****     } else {
 356:dfu.c         ****         /* we reset from the dfu, reset everything and startover,
 357:dfu.c         ****            which is the correct operation if this is an erroneous
 358:dfu.c         ****            event or properly following a MANIFEST */
 359:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 360:dfu.c         ****         dfuAppStatus.bStatus = OK;
 361:dfu.c         **** 
 362:dfu.c         ****         systemHardReset();
 363:dfu.c         ****     }
 364:dfu.c         **** }
 135              		.loc 1 364 0
 136 001c BDE80840 		pop	{r3, lr}
 351:dfu.c         ****         usbEnbISR();
 137              		.loc 1 351 0
 138 0020 FFF7FEBF 		b	usbEnbISR
 139              	.LVL3:
 140              	.L5:
 353:dfu.c         ****     } else if (startState == appIDLE || startState == dfuIDLE) {
 141              		.loc 1 353 0
 142 0024 11F0FD0F 		tst	r1, #253
 143 0028 06D0     		beq	.L4
 359:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 144              		.loc 1 359 0
 145 002a 0221     		movs	r1, #2
 146              	.LVL4:
 147 002c 1971     		strb	r1, [r3, #4]
 360:dfu.c         ****         dfuAppStatus.bStatus = OK;
 148              		.loc 1 360 0
 149 002e 1A70     		strb	r2, [r3]
 150              		.loc 1 364 0
 151 0030 BDE80840 		pop	{r3, lr}
 362:dfu.c         ****         systemHardReset();
 152              		.loc 1 362 0
 153 0034 FFF7FEBF 		b	systemHardReset
 154              	.LVL5:
 155              	.L4:
 156 0038 08BD     		pop	{r3, pc}
 157              	.L9:
 158 003a 00BF     		.align	2
 159              	.L8:
 160 003c 00000000 		.word	.LANCHOR0
 161 0040 00000000 		.word	.LANCHOR1
 162              		.cfi_endproc
 163              	.LFE2:
 165              		.section	.text.dfuUpdateByTimeout,"ax",%progbits
 166              		.align	1
 167              		.global	dfuUpdateByTimeout
 168              		.thumb
 169              		.thumb_func
 171              	dfuUpdateByTimeout:
 172              	.LFB3:
 365:dfu.c         **** 
 366:dfu.c         **** void dfuUpdateByTimeout(void) {
 173              		.loc 1 366 0
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178 0000 7047     		bx	lr
 179              		.cfi_endproc
 180              	.LFE3:
 182              		.section	.text.dfuCopyState,"ax",%progbits
 183              		.align	1
 184              		.global	dfuCopyState
 185              		.thumb
 186              		.thumb_func
 188              	dfuCopyState:
 189              	.LFB4:
 367:dfu.c         **** }
 368:dfu.c         **** 
 369:dfu.c         **** u8 *dfuCopyState(u16 length) {
 190              		.loc 1 369 0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		@ link register save eliminated.
 195              	.LVL6:
 370:dfu.c         ****     if (length == 0) {
 196              		.loc 1 370 0
 197 0000 20B9     		cbnz	r0, .L13
 371:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = 1;
 198              		.loc 1 371 0
 199 0002 034B     		ldr	r3, .L14
 200 0004 0122     		movs	r2, #1
 201 0006 1B68     		ldr	r3, [r3]
 202 0008 1A82     		strh	r2, [r3, #16]	@ movhi
 372:dfu.c         ****         return NULL;
 203              		.loc 1 372 0
 204 000a 7047     		bx	lr
 205              	.L13:
 373:dfu.c         ****     } else {
 374:dfu.c         ****         return (&(dfuAppStatus.bState));
 206              		.loc 1 374 0
 207 000c 0148     		ldr	r0, .L14+4
 208              	.LVL7:
 375:dfu.c         ****     }
 376:dfu.c         **** }
 209              		.loc 1 376 0
 210 000e 7047     		bx	lr
 211              	.L15:
 212              		.align	2
 213              	.L14:
 214 0010 00000000 		.word	pInformation
 215 0014 04000000 		.word	.LANCHOR0+4
 216              		.cfi_endproc
 217              	.LFE4:
 219              		.section	.text.dfuCopyStatus,"ax",%progbits
 220              		.align	1
 221              		.global	dfuCopyStatus
 222              		.thumb
 223              		.thumb_func
 225              	dfuCopyStatus:
 226              	.LFB5:
 377:dfu.c         **** 
 378:dfu.c         **** u8 *dfuCopyStatus(u16 length) {
 227              		.loc 1 378 0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 0
 230              		@ frame_needed = 0, uses_anonymous_args = 0
 231              		@ link register save eliminated.
 232              	.LVL8:
 379:dfu.c         ****     if (length == 0) {
 233              		.loc 1 379 0
 234 0000 20B9     		cbnz	r0, .L18
 380:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = 6;
 235              		.loc 1 380 0
 236 0002 034B     		ldr	r3, .L19
 237 0004 0622     		movs	r2, #6
 238 0006 1B68     		ldr	r3, [r3]
 239 0008 1A82     		strh	r2, [r3, #16]	@ movhi
 381:dfu.c         ****         return NULL;
 240              		.loc 1 381 0
 241 000a 7047     		bx	lr
 242              	.L18:
 382:dfu.c         ****     } else {
 383:dfu.c         ****         return (u8*)(&dfuAppStatus);
 243              		.loc 1 383 0
 244 000c 0148     		ldr	r0, .L19+4
 245              	.LVL9:
 384:dfu.c         ****     }
 385:dfu.c         **** }
 246              		.loc 1 385 0
 247 000e 7047     		bx	lr
 248              	.L20:
 249              		.align	2
 250              	.L19:
 251 0010 00000000 		.word	pInformation
 252 0014 00000000 		.word	.LANCHOR0
 253              		.cfi_endproc
 254              	.LFE5:
 256              		.section	.text.dfuCopyDNLOAD,"ax",%progbits
 257              		.align	1
 258              		.global	dfuCopyDNLOAD
 259              		.thumb
 260              		.thumb_func
 262              	dfuCopyDNLOAD:
 263              	.LFB6:
 386:dfu.c         **** 
 387:dfu.c         **** 
 388:dfu.c         **** u8 *dfuCopyDNLOAD(u16 length) {
 264              		.loc 1 388 0
 265              		.cfi_startproc
 266              		@ args = 0, pretend = 0, frame = 0
 267              		@ frame_needed = 0, uses_anonymous_args = 0
 268              		@ link register save eliminated.
 269              	.LVL10:
 270 0000 064B     		ldr	r3, .L24
 389:dfu.c         ****     if (length == 0) {
 390:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info
 271              		.loc 1 390 0
 272 0002 1B68     		ldr	r3, [r3]
 389:dfu.c         ****     if (length == 0) {
 273              		.loc 1 389 0
 274 0004 30B9     		cbnz	r0, .L22
 275              		.loc 1 390 0
 276 0006 DA88     		ldrh	r2, [r3, #6]
 277 0008 598A     		ldrh	r1, [r3, #18]
 278 000a 511A     		subs	r1, r2, r1
 279 000c 1982     		strh	r1, [r3, #16]	@ movhi
 391:dfu.c         ****         thisBlockLen = pInformation->USBwLengths.w;
 280              		.loc 1 391 0
 281 000e 044B     		ldr	r3, .L24+4
 282 0010 1A80     		strh	r2, [r3]	@ movhi
 392:dfu.c         ****         return NULL;
 283              		.loc 1 392 0
 284 0012 7047     		bx	lr
 285              	.L22:
 393:dfu.c         ****     } else {
 394:dfu.c         ****         return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
 286              		.loc 1 394 0
 287 0014 5B8A     		ldrh	r3, [r3, #18]
 288 0016 0348     		ldr	r0, .L24+8
 289              	.LVL11:
 290 0018 1844     		add	r0, r0, r3
 395:dfu.c         ****     }
 396:dfu.c         **** }
 291              		.loc 1 396 0
 292 001a 7047     		bx	lr
 293              	.L25:
 294              		.align	2
 295              	.L24:
 296 001c 00000000 		.word	pInformation
 297 0020 00000000 		.word	.LANCHOR2
 298 0024 00000000 		.word	.LANCHOR7
 299              		.cfi_endproc
 300              	.LFE6:
 302              		.section	.text.dfuCopyUPLOAD,"ax",%progbits
 303              		.align	1
 304              		.global	dfuCopyUPLOAD
 305              		.thumb
 306              		.thumb_func
 308              	dfuCopyUPLOAD:
 309              	.LFB7:
 397:dfu.c         **** 
 398:dfu.c         **** u8 *dfuCopyUPLOAD(u16 length) {
 310              		.loc 1 398 0
 311              		.cfi_startproc
 312              		@ args = 0, pretend = 0, frame = 0
 313              		@ frame_needed = 0, uses_anonymous_args = 0
 314              		@ link register save eliminated.
 315              	.LVL12:
 316 0000 084B     		ldr	r3, .L29
 399:dfu.c         ****     if (length == 0) {
 317              		.loc 1 399 0
 318 0002 30B9     		cbnz	r0, .L27
 400:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
 319              		.loc 1 400 0
 320 0004 1B68     		ldr	r3, [r3]
 321 0006 084A     		ldr	r2, .L29+4
 322 0008 1188     		ldrh	r1, [r2]
 323 000a 5A8A     		ldrh	r2, [r3, #18]
 324 000c 8A1A     		subs	r2, r1, r2
 325 000e 1A82     		strh	r2, [r3, #16]	@ movhi
 401:dfu.c         ****         return NULL;
 326              		.loc 1 401 0
 327 0010 7047     		bx	lr
 328              	.L27:
 402:dfu.c         ****     } else {
 403:dfu.c         ****         return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
 329              		.loc 1 403 0
 330 0012 0649     		ldr	r1, .L29+8
 331 0014 064A     		ldr	r2, .L29+12
 332 0016 1B68     		ldr	r3, [r3]
 333 0018 1268     		ldr	r2, [r2]
 334 001a 0868     		ldr	r0, [r1]
 335              	.LVL13:
 336 001c 5B8A     		ldrh	r3, [r3, #18]
 337 001e 1044     		add	r0, r0, r2
 338 0020 1844     		add	r0, r0, r3
 404:dfu.c         ****     }
 405:dfu.c         **** }
 339              		.loc 1 405 0
 340 0022 7047     		bx	lr
 341              	.L30:
 342              		.align	2
 343              	.L29:
 344 0024 00000000 		.word	pInformation
 345 0028 00000000 		.word	.LANCHOR2
 346 002c 00000000 		.word	.LANCHOR3
 347 0030 00000000 		.word	.LANCHOR1
 348              		.cfi_endproc
 349              	.LFE7:
 351              		.section	.text.dfuCopyBufferToExec,"ax",%progbits
 352              		.align	1
 353              		.global	dfuCopyBufferToExec
 354              		.thumb
 355              		.thumb_func
 357              	dfuCopyBufferToExec:
 358              	.LFB8:
 406:dfu.c         **** 
 407:dfu.c         **** void dfuCopyBufferToExec() {
 359              		.loc 1 407 0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 0
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363 0000 70B5     		push	{r4, r5, r6, lr}
 364              		.cfi_def_cfa_offset 16
 365              		.cfi_offset 4, -16
 366              		.cfi_offset 5, -12
 367              		.cfi_offset 6, -8
 368              		.cfi_offset 14, -4
 408:dfu.c         ****     int i;
 409:dfu.c         ****     u32 *userSpace;
 410:dfu.c         **** 	
 411:dfu.c         **** /* Roger Clark. 
 412:dfu.c         **** 	Commented out code associated with upload to RAM
 413:dfu.c         **** 
 414:dfu.c         ****     if (userUploadType == DFU_UPLOAD_RAM) 
 415:dfu.c         **** 	{
 416:dfu.c         ****         userSpace = (u32 *)(USER_CODE_RAM + userFirmwareLen);
 417:dfu.c         ****         // we dont need to handle when thisBlock len is not divisible by 4,
 418:dfu.c         ****         //   since the linker will align everything to 4B anyway 
 419:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 420:dfu.c         ****             *userSpace++ = *(u32 *)(recvBuffer + i);
 421:dfu.c         ****         }
 422:dfu.c         ****     } 
 423:dfu.c         **** 	else 
 424:dfu.c         **** */
 425:dfu.c         **** 	{
 426:dfu.c         **** 		if (userUploadType == DFU_UPLOAD_FLASH_0X8005000)
 369              		.loc 1 426 0
 370 0002 124B     		ldr	r3, .L37
 371 0004 124E     		ldr	r6, .L37+4
 372 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 427:dfu.c         **** 		{
 428:dfu.c         **** 			userSpace = (u32 *)(USER_CODE_FLASH0X8005000 + userFirmwareLen);
 373              		.loc 1 428 0
 374 0008 3468     		ldr	r4, [r6]
 426:dfu.c         **** 		if (userUploadType == DFU_UPLOAD_FLASH_0X8005000)
 375              		.loc 1 426 0
 376 000a 022B     		cmp	r3, #2
 377              		.loc 1 428 0
 378 000c 04F10064 		add	r4, r4, #134217728
 379 0010 0CBF     		ite	eq
 380 0012 04F5A044 		addeq	r4, r4, #20480
 381              	.LVL14:
 429:dfu.c         **** 		}
 430:dfu.c         **** 		else
 431:dfu.c         **** 		{
 432:dfu.c         **** 			userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
 382              		.loc 1 432 0
 383 0016 04F50054 		addne	r4, r4, #8192
 433:dfu.c         **** 		}
 434:dfu.c         **** 
 435:dfu.c         ****         flashErasePage((u32)(userSpace));
 384              		.loc 1 435 0
 385 001a 2046     		mov	r0, r4
 386 001c FFF7FEFF 		bl	flashErasePage
 387              	.LVL15:
 436:dfu.c         **** 
 437:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 388              		.loc 1 437 0
 389 0020 0025     		movs	r5, #0
 390              	.LVL16:
 391              	.L34:
 392              		.loc 1 437 0 is_stmt 0 discriminator 1
 393 0022 0C4B     		ldr	r3, .L37+8
 394 0024 1A88     		ldrh	r2, [r3]
 395 0026 92B2     		uxth	r2, r2
 396 0028 9542     		cmp	r5, r2
 397 002a 06DA     		bge	.L36
 438:dfu.c         ****             flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 398              		.loc 1 438 0 is_stmt 1 discriminator 2
 399 002c 0A4B     		ldr	r3, .L37+12
 400 002e 6019     		adds	r0, r4, r5
 401 0030 E958     		ldr	r1, [r5, r3]
 402 0032 FFF7FEFF 		bl	flashWriteWord
 403              	.LVL17:
 437:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 404              		.loc 1 437 0 discriminator 2
 405 0036 0435     		adds	r5, r5, #4
 406              	.LVL18:
 407 0038 F3E7     		b	.L34
 408              	.L36:
 439:dfu.c         ****         }
 440:dfu.c         **** 
 441:dfu.c         ****     }
 442:dfu.c         ****     userFirmwareLen += thisBlockLen;
 409              		.loc 1 442 0
 410 003a 3168     		ldr	r1, [r6]
 411 003c 1A88     		ldrh	r2, [r3]
 412 003e 92B2     		uxth	r2, r2
 413 0040 0A44     		add	r2, r2, r1
 414 0042 3260     		str	r2, [r6]
 443:dfu.c         **** 
 444:dfu.c         ****     thisBlockLen = 0;
 415              		.loc 1 444 0
 416 0044 0022     		movs	r2, #0
 417 0046 1A80     		strh	r2, [r3]	@ movhi
 418 0048 70BD     		pop	{r4, r5, r6, pc}
 419              	.LVL19:
 420              	.L38:
 421 004a 00BF     		.align	2
 422              	.L37:
 423 004c 00000000 		.word	.LANCHOR5
 424 0050 00000000 		.word	.LANCHOR1
 425 0054 00000000 		.word	.LANCHOR2
 426 0058 00000000 		.word	.LANCHOR7
 427              		.cfi_endproc
 428              	.LFE8:
 430              		.section	.text.dfuUpdateByRequest,"ax",%progbits
 431              		.align	1
 432              		.global	dfuUpdateByRequest
 433              		.thumb
 434              		.thumb_func
 436              	dfuUpdateByRequest:
 437              	.LFB1:
  75:dfu.c         **** bool dfuUpdateByRequest(void) {
 438              		.loc 1 75 0
 439              		.cfi_startproc
 440              		@ args = 0, pretend = 0, frame = 0
 441              		@ frame_needed = 0, uses_anonymous_args = 0
 442 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 443              		.cfi_def_cfa_offset 24
 444              		.cfi_offset 4, -24
 445              		.cfi_offset 5, -20
 446              		.cfi_offset 6, -16
 447              		.cfi_offset 7, -12
 448              		.cfi_offset 8, -8
 449              		.cfi_offset 14, -4
  78:dfu.c         ****     dfuBusy = TRUE;
 450              		.loc 1 78 0
 451 0004 7F49     		ldr	r1, .L100
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 452              		.loc 1 82 0
 453 0006 804C     		ldr	r4, .L100+4
  78:dfu.c         ****     dfuBusy = TRUE;
 454              		.loc 1 78 0
 455 0008 0120     		movs	r0, #1
 456 000a 0870     		strb	r0, [r1]
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 457              		.loc 1 82 0
 458 000c 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
  83:dfu.c         ****     dfuAppStatus.bStatus = OK;
 459              		.loc 1 83 0
 460 000e 0022     		movs	r2, #0
  82:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 461              		.loc 1 82 0
 462 0010 DBB2     		uxtb	r3, r3
 463              	.LVL20:
  85:dfu.c         ****     if (startState == dfuIDLE)  {
 464              		.loc 1 85 0
 465 0012 022B     		cmp	r3, #2
  83:dfu.c         ****     dfuAppStatus.bStatus = OK;
 466              		.loc 1 83 0
 467 0014 2270     		strb	r2, [r4]
  85:dfu.c         ****     if (startState == dfuIDLE)  {
 468              		.loc 1 85 0
 469 0016 56D1     		bne	.L40
  87:dfu.c         ****         dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
 470              		.loc 1 87 0
 471 0018 0870     		strb	r0, [r1]
  89:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
 472              		.loc 1 89 0
 473 001a 7C49     		ldr	r1, .L100+8
 474 001c 0968     		ldr	r1, [r1]
 475 001e 4878     		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 476 0020 0128     		cmp	r0, #1
 477 0022 26D1     		bne	.L41
  91:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 478              		.loc 1 91 0
 479 0024 C888     		ldrh	r0, [r1, #6]
 480 0026 0028     		cmp	r0, #0
 481 0028 00F0C180 		beq	.L72
  92:dfu.c         ****                 userFirmwareLen = 0;
 482              		.loc 1 92 0
 483 002c 7848     		ldr	r0, .L100+12
  94:dfu.c         **** 				switch(pInformation->Current_AlternateSetting)
 484              		.loc 1 94 0
 485 002e 097B     		ldrb	r1, [r1, #12]	@ zero_extendqisi2
  92:dfu.c         ****                 userFirmwareLen = 0;
 486              		.loc 1 92 0
 487 0030 0260     		str	r2, [r0]
  94:dfu.c         **** 				switch(pInformation->Current_AlternateSetting)
 488              		.loc 1 94 0
 489 0032 0129     		cmp	r1, #1
  93:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 490              		.loc 1 93 0
 491 0034 4FF00302 		mov	r2, #3
 492 0038 2271     		strb	r2, [r4, #4]
  94:dfu.c         **** 				switch(pInformation->Current_AlternateSetting)
 493              		.loc 1 94 0
 494 003a 0BD0     		beq	.L44
 495 003c 0229     		cmp	r1, #2
 496 003e 16D1     		bne	.L98
 114:dfu.c         **** 						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
 497              		.loc 1 114 0
 498 0040 744B     		ldr	r3, .L100+16
 499              	.LVL21:
 500 0042 1A70     		strb	r2, [r3]
 115:dfu.c         **** 						userAppAddr = USER_CODE_FLASH0X8002000;
 501              		.loc 1 115 0
 502 0044 744A     		ldr	r2, .L100+20
 503 0046 754B     		ldr	r3, .L100+24
 504 0048 1A60     		str	r2, [r3]
 117:dfu.c         **** 						setupFLASH();
 505              		.loc 1 117 0
 506 004a FFF7FEFF 		bl	setupFLASH
 507              	.LVL22:
 118:dfu.c         **** 						flashUnlock();
 508              		.loc 1 118 0
 509 004e FFF7FEFF 		bl	flashUnlock
 510              	.LVL23:
 119:dfu.c         **** 						break;
 511              		.loc 1 119 0
 512 0052 CFE0     		b	.L46
 513              	.LVL24:
 514              	.L44:
 104:dfu.c         **** 					    userAppAddr = USER_CODE_FLASH0X8005000;
 515              		.loc 1 104 0
 516 0054 7249     		ldr	r1, .L100+28
 517 0056 714A     		ldr	r2, .L100+24
 518 0058 1160     		str	r1, [r2]
 105:dfu.c         **** 						userUploadType = DFU_UPLOAD_FLASH_0X8005000;
 519              		.loc 1 105 0
 520 005a 6E4A     		ldr	r2, .L100+16
 521 005c 1370     		strb	r3, [r2]
 108:dfu.c         **** 						setupFLASH();
 522              		.loc 1 108 0
 523 005e FFF7FEFF 		bl	setupFLASH
 524              	.LVL25:
 109:dfu.c         **** 						flashUnlock();
 525              		.loc 1 109 0
 526 0062 FFF7FEFF 		bl	flashUnlock
 527              	.LVL26:
 111:dfu.c         **** 						flashErasePage((u32)USER_CODE_FLASH0X8002000);
 528              		.loc 1 111 0
 529 0066 6C48     		ldr	r0, .L100+20
 530 0068 FFF7FEFF 		bl	flashErasePage
 531              	.LVL27:
 112:dfu.c         **** 						break;
 532              		.loc 1 112 0
 533 006c C2E0     		b	.L46
 534              	.LVL28:
 535              	.L98:
 122:dfu.c         **** 						dfuAppStatus.bState  = dfuERROR;
 536              		.loc 1 122 0
 537 006e 0A23     		movs	r3, #10
 538              	.LVL29:
 539 0070 62E0     		b	.L88
 540              	.LVL30:
 541              	.L41:
 130:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_UPLOAD) {
 542              		.loc 1 130 0
 543 0072 0228     		cmp	r0, #2
 544 0074 21D1     		bne	.L47
 131:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 545              		.loc 1 131 0
 546 0076 0923     		movs	r3, #9
 547              	.LVL31:
 548 0078 2371     		strb	r3, [r4, #4]
 134:dfu.c         ****             uploadBlockLen = pInformation->USBwLengths.w;
 549              		.loc 1 134 0
 550 007a CA88     		ldrh	r2, [r1, #6]
 551 007c 694B     		ldr	r3, .L100+32
 552 007e 1A80     		strh	r2, [r3]	@ movhi
 135:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 553              		.loc 1 135 0
 554 0080 1888     		ldrh	r0, [r3]
 555 0082 694A     		ldr	r2, .L100+36
 556 0084 80B2     		uxth	r0, r0
 557 0086 1080     		strh	r0, [r2]	@ movhi
 137:dfu.c         ****             userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 558              		.loc 1 137 0
 559 0088 1A88     		ldrh	r2, [r3]
 560 008a 4B88     		ldrh	r3, [r1, #2]
 561 008c 92B2     		uxth	r2, r2
 562 008e 5A43     		muls	r2, r3, r2
 563 0090 5F4B     		ldr	r3, .L100+12
 564 0092 1A60     		str	r2, [r3]
 138:dfu.c         **** 			switch(pInformation->Current_AlternateSetting)
 565              		.loc 1 138 0
 566 0094 0B7B     		ldrb	r3, [r1, #12]	@ zero_extendqisi2
 567 0096 012B     		cmp	r3, #1
 568 0098 03D0     		beq	.L49
 569 009a 022B     		cmp	r3, #2
 570 009c 09D1     		bne	.L99
 150:dfu.c         **** 				    userAppAddr = USER_CODE_FLASH0X8002000;
 571              		.loc 1 150 0
 572 009e 5E4A     		ldr	r2, .L100+20
 573 00a0 00E0     		b	.L84
 574              	.L49:
 146:dfu.c         **** 				    userAppAddr = USER_CODE_FLASH0X8005000;
 575              		.loc 1 146 0
 576 00a2 5F4A     		ldr	r2, .L100+28
 577              	.L84:
 150:dfu.c         **** 				    userAppAddr = USER_CODE_FLASH0X8002000;
 578              		.loc 1 150 0
 579 00a4 5D4B     		ldr	r3, .L100+24
 580 00a6 1A60     		str	r2, [r3]
 151:dfu.c         **** 					userAppEnd = getFlashEnd();
 581              		.loc 1 151 0
 582 00a8 FFF7FEFF 		bl	getFlashEnd
 583              	.LVL32:
 584 00ac 5F4B     		ldr	r3, .L100+40
 585 00ae 1860     		str	r0, [r3]
 152:dfu.c         **** 					break;
 586              		.loc 1 152 0
 587 00b0 A0E0     		b	.L46
 588              	.L99:
 157:dfu.c         **** 					dfuAppStatus.bState  = dfuERROR;
 589              		.loc 1 157 0
 590 00b2 0A23     		movs	r3, #10
 591 00b4 2371     		strb	r3, [r4, #4]
 158:dfu.c         **** 					dfuAppStatus.bStatus = errWRITE;
 592              		.loc 1 158 0
 593 00b6 0323     		movs	r3, #3
 594 00b8 9BE0     		b	.L85
 595              	.LVL33:
 596              	.L47:
 161:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 597              		.loc 1 161 0
 598 00ba 0628     		cmp	r0, #6
 599 00bc 3CD0     		beq	.L88
 164:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 600              		.loc 1 164 0
 601 00be 0328     		cmp	r0, #3
 602 00c0 19D0     		beq	.L87
 166:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 603              		.loc 1 166 0
 604 00c2 0528     		cmp	r0, #5
 605 00c4 3CE0     		b	.L94
 606              	.L40:
 173:dfu.c         ****     } else if (startState == dfuDNLOAD_SYNC)         {
 607              		.loc 1 173 0
 608 00c6 032B     		cmp	r3, #3
 609 00c8 0BD1     		bne	.L54
 176:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 610              		.loc 1 176 0
 611 00ca 504A     		ldr	r2, .L100+8
 612 00cc 1268     		ldr	r2, [r2]
 613 00ce 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 614 00d0 032A     		cmp	r2, #3
 615 00d2 04D1     		bne	.L55
 205:dfu.c         ****                 dfuAppStatus.bState = dfuDNLOAD_IDLE;
 616              		.loc 1 205 0
 617 00d4 0523     		movs	r3, #5
 618              	.LVL34:
 619 00d6 2371     		strb	r3, [r4, #4]
 206:dfu.c         ****                 dfuCopyBufferToExec();
 620              		.loc 1 206 0
 621 00d8 FFF7FEFF 		bl	dfuCopyBufferToExec
 622              	.LVL35:
 623 00dc 8AE0     		b	.L46
 624              	.LVL36:
 625              	.L55:
 209:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 626              		.loc 1 209 0
 627 00de 052A     		cmp	r2, #5
 628 00e0 2EE0     		b	.L94
 629              	.L54:
 216:dfu.c         ****     } else if (startState == dfuDNBUSY)              {
 630              		.loc 1 216 0
 631 00e2 042B     		cmp	r3, #4
 632 00e4 09D1     		bne	.L57
 218:dfu.c         ****         if (code_copy_lock == END) {
 633              		.loc 1 218 0
 634 00e6 5249     		ldr	r1, .L100+44
 635 00e8 0878     		ldrb	r0, [r1]	@ zero_extendqisi2
 636 00ea 0228     		cmp	r0, #2
 637 00ec 03D1     		bne	.L87
 220:dfu.c         ****             code_copy_lock = WAIT;
 638              		.loc 1 220 0
 639 00ee 0323     		movs	r3, #3
 640              	.LVL37:
 219:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 641              		.loc 1 219 0
 642 00f0 6270     		strb	r2, [r4, #1]
 220:dfu.c         ****             code_copy_lock = WAIT;
 643              		.loc 1 220 0
 644 00f2 0B70     		strb	r3, [r1]
 221:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 645              		.loc 1 221 0
 646 00f4 0523     		movs	r3, #5
 647              	.L87:
 648 00f6 2371     		strb	r3, [r4, #4]
 649 00f8 7CE0     		b	.L46
 650              	.LVL38:
 651              	.L57:
 226:dfu.c         ****     } else if (startState == dfuDNLOAD_IDLE)         {
 652              		.loc 1 226 0
 653 00fa 052B     		cmp	r3, #5
 654 00fc 14D1     		bne	.L59
 228:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
 655              		.loc 1 228 0
 656 00fe 434B     		ldr	r3, .L100+8
 657              	.LVL39:
 658 0100 1A68     		ldr	r2, [r3]
 659 0102 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 660 0104 012B     		cmp	r3, #1
 661 0106 08D1     		bne	.L60
 229:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 662              		.loc 1 229 0
 663 0108 D388     		ldrh	r3, [r2, #6]
 664 010a 0BB1     		cbz	r3, .L61
 230:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 665              		.loc 1 230 0
 666 010c 0323     		movs	r3, #3
 667 010e F2E7     		b	.L87
 668              	.L61:
 233:dfu.c         ****                 dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 669              		.loc 1 233 0
 670 0110 0623     		movs	r3, #6
 671 0112 2371     		strb	r3, [r4, #4]
 236:dfu.c         ****                 flashLock();
 672              		.loc 1 236 0
 673 0114 FFF7FEFF 		bl	flashLock
 674              	.LVL40:
 675 0118 6CE0     		b	.L46
 676              	.L60:
 238:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 677              		.loc 1 238 0
 678 011a 062B     		cmp	r3, #6
 679 011c 4DD0     		beq	.L97
 240:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 680              		.loc 1 240 0
 681 011e 032B     		cmp	r3, #3
 682 0120 4BD0     		beq	.L97
 242:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 683              		.loc 1 242 0
 684 0122 052B     		cmp	r3, #5
 685 0124 62D1     		bne	.L78
 686 0126 48E0     		b	.L97
 687              	.LVL41:
 688              	.L59:
 249:dfu.c         ****     } else if (startState == dfuMANIFEST_SYNC)       {
 689              		.loc 1 249 0
 690 0128 062B     		cmp	r3, #6
 691 012a 0BD1     		bne	.L65
 252:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 692              		.loc 1 252 0
 693 012c 3749     		ldr	r1, .L100+8
 694 012e 0968     		ldr	r1, [r1]
 695 0130 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 696 0132 0329     		cmp	r1, #3
 697 0134 03D1     		bne	.L66
 698              	.L89:
 253:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 699              		.loc 1 253 0
 700 0136 0823     		movs	r3, #8
 701              	.LVL42:
 702              	.L88:
 703 0138 2371     		strb	r3, [r4, #4]
 254:dfu.c         ****             dfuAppStatus.bStatus = OK;
 704              		.loc 1 254 0
 705 013a 2270     		strb	r2, [r4]
 706 013c 5AE0     		b	.L46
 707              	.LVL43:
 708              	.L66:
 255:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 709              		.loc 1 255 0
 710 013e 0529     		cmp	r1, #5
 711              	.L94:
 712 0140 54D1     		bne	.L78
 713 0142 D8E7     		b	.L87
 714              	.L65:
 262:dfu.c         ****     } else if (startState == dfuMANIFEST)            {
 715              		.loc 1 262 0
 716 0144 072B     		cmp	r3, #7
 717 0146 F6D0     		beq	.L89
 269:dfu.c         ****     } else if (startState == dfuMANIFEST_WAIT_RESET) {
 718              		.loc 1 269 0
 719 0148 082B     		cmp	r3, #8
 720 014a D4D0     		beq	.L87
 276:dfu.c         ****     } else if (startState == dfuUPLOAD_IDLE)         {
 721              		.loc 1 276 0
 722 014c 092B     		cmp	r3, #9
 723 014e 3CD1     		bne	.L70
 279:dfu.c         ****         if (pInformation->USBbRequest == DFU_UPLOAD) {
 724              		.loc 1 279 0
 725 0150 2E4B     		ldr	r3, .L100+8
 726              	.LVL44:
 727 0152 1A68     		ldr	r2, [r3]
 728 0154 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 729 0156 022B     		cmp	r3, #2
 730 0158 2DD1     		bne	.L71
 280:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 731              		.loc 1 280 0
 732 015a D088     		ldrh	r0, [r2, #6]
 733 015c 38B3     		cbz	r0, .L72
 282:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 734              		.loc 1 282 0
 735 015e 3149     		ldr	r1, .L100+32
 736 0160 5288     		ldrh	r2, [r2, #2]
 737 0162 0B88     		ldrh	r3, [r1]
 283:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 738              		.loc 1 283 0
 739 0164 2D4D     		ldr	r5, .L100+24
 282:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 740              		.loc 1 282 0
 741 0166 9BB2     		uxth	r3, r3
 742 0168 5343     		muls	r3, r2, r3
 743 016a 294A     		ldr	r2, .L100+12
 283:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 744              		.loc 1 283 0
 745 016c 2F4E     		ldr	r6, .L100+40
 282:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 746              		.loc 1 282 0
 747 016e 1360     		str	r3, [r2]
 283:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 748              		.loc 1 283 0
 749 0170 2F68     		ldr	r7, [r5]
 750 0172 D2F80080 		ldr	r8, [r2]
 751 0176 B1F800C0 		ldrh	ip, [r1]
 752 017a 4744     		add	r7, r7, r8
 753 017c 3368     		ldr	r3, [r6]
 754 017e 1FFA8CFC 		uxth	ip, ip
 755 0182 6744     		add	r7, r7, ip
 756 0184 9F42     		cmp	r7, r3
 757 0186 284B     		ldr	r3, .L100+36
 758 0188 03D8     		bhi	.L73
 284:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 759              		.loc 1 284 0
 760 018a 0A88     		ldrh	r2, [r1]
 761 018c 92B2     		uxth	r2, r2
 762 018e 1A80     		strh	r2, [r3]	@ movhi
 763 0190 19E0     		b	.L96
 764              	.L73:
 289:dfu.c         ****                     thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
 765              		.loc 1 289 0
 766 0192 3668     		ldr	r6, [r6]
 767 0194 2D68     		ldr	r5, [r5]
 768 0196 1168     		ldr	r1, [r2]
 769 0198 721B     		subs	r2, r6, r5
 770 019a 521A     		subs	r2, r2, r1
 771 019c 92B2     		uxth	r2, r2
 772 019e 1A80     		strh	r2, [r3]	@ movhi
 291:dfu.c         ****                     if (thisBlockLen >= pInformation->USBwLengths.w) {
 773              		.loc 1 291 0
 774 01a0 1A88     		ldrh	r2, [r3]
 775 01a2 92B2     		uxth	r2, r2
 776 01a4 8242     		cmp	r2, r0
 777 01a6 08D3     		bcc	.L97
 292:dfu.c         ****                         thisBlockLen = 0;
 778              		.loc 1 292 0
 779 01a8 0022     		movs	r2, #0
 780 01aa 1A80     		strh	r2, [r3]	@ movhi
 781 01ac 05E0     		b	.L97
 782              	.L72:
 297:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 783              		.loc 1 297 0
 784 01ae 0A23     		movs	r3, #10
 785 01b0 2371     		strb	r3, [r4, #4]
 298:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 786              		.loc 1 298 0
 787 01b2 0923     		movs	r3, #9
 788 01b4 1DE0     		b	.L85
 789              	.L71:
 300:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 790              		.loc 1 300 0
 791 01b6 062B     		cmp	r3, #6
 792 01b8 01D1     		bne	.L75
 793              	.L97:
 301:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 794              		.loc 1 301 0
 795 01ba 0223     		movs	r3, #2
 796 01bc 9BE7     		b	.L87
 797              	.L75:
 302:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 798              		.loc 1 302 0
 799 01be 032B     		cmp	r3, #3
 800 01c0 01D0     		beq	.L96
 304:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 801              		.loc 1 304 0
 802 01c2 052B     		cmp	r3, #5
 803 01c4 12D1     		bne	.L78
 804              	.L96:
 305:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 805              		.loc 1 305 0
 806 01c6 0923     		movs	r3, #9
 807 01c8 95E7     		b	.L87
 808              	.LVL45:
 809              	.L70:
 312:dfu.c         ****     } else if (startState == dfuERROR)               {
 810              		.loc 1 312 0
 811 01ca 0A2B     		cmp	r3, #10
 812 01cc 0ED1     		bne	.L78
 315:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 813              		.loc 1 315 0
 814 01ce 0F4B     		ldr	r3, .L100+8
 815              	.LVL46:
 816 01d0 1B68     		ldr	r3, [r3]
 817 01d2 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 818 01d4 032B     		cmp	r3, #3
 819 01d6 01D1     		bne	.L79
 820              	.L92:
 317:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 821              		.loc 1 317 0
 822 01d8 0A23     		movs	r3, #10
 823 01da 8CE7     		b	.L87
 824              	.L79:
 318:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 825              		.loc 1 318 0
 826 01dc 052B     		cmp	r3, #5
 827 01de FBD0     		beq	.L92
 320:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
 828              		.loc 1 320 0
 829 01e0 042B     		cmp	r3, #4
 830 01e2 03D1     		bne	.L78
 322:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 831              		.loc 1 322 0
 832 01e4 0223     		movs	r3, #2
 833 01e6 2371     		strb	r3, [r4, #4]
 323:dfu.c         ****             dfuAppStatus.bStatus = OK;
 834              		.loc 1 323 0
 835 01e8 0023     		movs	r3, #0
 836 01ea 02E0     		b	.L85
 837              	.L78:
 331:dfu.c         ****         dfuAppStatus.bState  = dfuERROR;
 838              		.loc 1 331 0
 839 01ec 0A23     		movs	r3, #10
 840 01ee 2371     		strb	r3, [r4, #4]
 332:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 841              		.loc 1 332 0
 842 01f0 0F23     		movs	r3, #15
 843              	.L85:
 844 01f2 2370     		strb	r3, [r4]
 845              	.L46:
 335:dfu.c         ****     if (dfuAppStatus.bStatus == OK) {
 846              		.loc 1 335 0
 847 01f4 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 340:dfu.c         **** }
 848              		.loc 1 340 0
 849 01f6 D0F10100 		rsbs	r0, r0, #1
 850 01fa 38BF     		it	cc
 851 01fc 0020     		movcc	r0, #0
 852 01fe BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 853              	.L101:
 854 0202 00BF     		.align	2
 855              	.L100:
 856 0204 00000000 		.word	.LANCHOR6
 857 0208 00000000 		.word	.LANCHOR0
 858 020c 00000000 		.word	pInformation
 859 0210 00000000 		.word	.LANCHOR1
 860 0214 00000000 		.word	.LANCHOR5
 861 0218 00200008 		.word	134225920
 862 021c 00000000 		.word	.LANCHOR3
 863 0220 00500008 		.word	134238208
 864 0224 00000000 		.word	.LANCHOR8
 865 0228 00000000 		.word	.LANCHOR2
 866 022c 00000000 		.word	.LANCHOR4
 867 0230 00000000 		.word	code_copy_lock
 868              		.cfi_endproc
 869              	.LFE1:
 871              		.section	.text.dfuGetState,"ax",%progbits
 872              		.align	1
 873              		.global	dfuGetState
 874              		.thumb
 875              		.thumb_func
 877              	dfuGetState:
 878              	.LFB9:
 445:dfu.c         **** }
 446:dfu.c         **** 
 447:dfu.c         **** u8 dfuGetState(void) {
 879              		.loc 1 447 0
 880              		.cfi_startproc
 881              		@ args = 0, pretend = 0, frame = 0
 882              		@ frame_needed = 0, uses_anonymous_args = 0
 883              		@ link register save eliminated.
 448:dfu.c         ****     return dfuAppStatus.bState;
 884              		.loc 1 448 0
 885 0000 014B     		ldr	r3, .L103
 886 0002 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 449:dfu.c         **** }
 887              		.loc 1 449 0
 888 0004 7047     		bx	lr
 889              	.L104:
 890 0006 00BF     		.align	2
 891              	.L103:
 892 0008 00000000 		.word	.LANCHOR0
 893              		.cfi_endproc
 894              	.LFE9:
 896              		.section	.text.dfuSetState,"ax",%progbits
 897              		.align	1
 898              		.global	dfuSetState
 899              		.thumb
 900              		.thumb_func
 902              	dfuSetState:
 903              	.LFB10:
 450:dfu.c         **** 
 451:dfu.c         **** void dfuSetState(u8 newState) {
 904              		.loc 1 451 0
 905              		.cfi_startproc
 906              		@ args = 0, pretend = 0, frame = 0
 907              		@ frame_needed = 0, uses_anonymous_args = 0
 908              		@ link register save eliminated.
 909              	.LVL47:
 452:dfu.c         ****     dfuAppStatus.bState = newState;
 910              		.loc 1 452 0
 911 0000 014B     		ldr	r3, .L106
 912 0002 1871     		strb	r0, [r3, #4]
 913 0004 7047     		bx	lr
 914              	.L107:
 915 0006 00BF     		.align	2
 916              	.L106:
 917 0008 00000000 		.word	.LANCHOR0
 918              		.cfi_endproc
 919              	.LFE10:
 921              		.section	.text.dfuUploadStarted,"ax",%progbits
 922              		.align	1
 923              		.global	dfuUploadStarted
 924              		.thumb
 925              		.thumb_func
 927              	dfuUploadStarted:
 928              	.LFB11:
 453:dfu.c         **** }
 454:dfu.c         **** 
 455:dfu.c         **** bool dfuUploadStarted() {
 929              		.loc 1 455 0
 930              		.cfi_startproc
 931              		@ args = 0, pretend = 0, frame = 0
 932              		@ frame_needed = 0, uses_anonymous_args = 0
 933              		@ link register save eliminated.
 456:dfu.c         ****     return dfuBusy;
 934              		.loc 1 456 0
 935 0000 014B     		ldr	r3, .L109
 936 0002 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 457:dfu.c         **** }
 937              		.loc 1 457 0
 938 0004 7047     		bx	lr
 939              	.L110:
 940 0006 00BF     		.align	2
 941              	.L109:
 942 0008 00000000 		.word	.LANCHOR6
 943              		.cfi_endproc
 944              	.LFE11:
 946              		.section	.text.dfuFinishUpload,"ax",%progbits
 947              		.align	1
 948              		.global	dfuFinishUpload
 949              		.thumb
 950              		.thumb_func
 952              	dfuFinishUpload:
 953              	.LFB12:
 458:dfu.c         **** 
 459:dfu.c         **** void dfuFinishUpload() {
 954              		.loc 1 459 0
 955              		.cfi_startproc
 956              		@ Volatile: function does not return.
 957              		@ args = 0, pretend = 0, frame = 0
 958              		@ frame_needed = 0, uses_anonymous_args = 0
 959              		@ link register save eliminated.
 960              	.L112:
 460:dfu.c         ****     while (1)
 461:dfu.c         **** 	{
 462:dfu.c         **** 		__asm("nop");
 961              		.loc 1 462 0 discriminator 1
 962              	@ 462 "dfu.c" 1
 963 0000 00BF     		nop
 964              	@ 0 "" 2
 965              		.thumb
 966 0002 FDE7     		b	.L112
 967              		.cfi_endproc
 968              	.LFE12:
 970              		.comm	code_copy_lock,1,1
 971              		.global	dfuBusy
 972              		.global	userUploadType
 973              		.comm	wTransferSize,4,4
 974              		.section	.bss.recvBuffer,"aw",%nobits
 975              		.align	2
 976              		.set	.LANCHOR7,. + 0
 979              	recvBuffer:
 980 0000 00000000 		.space	2048
 980      00000000 
 980      00000000 
 980      00000000 
 980      00000000 
 981              		.section	.bss.uploadBlockLen,"aw",%nobits
 982              		.align	1
 983              		.set	.LANCHOR8,. + 0
 986              	uploadBlockLen:
 987 0000 0000     		.space	2
 988              		.section	.bss.thisBlockLen,"aw",%nobits
 989              		.align	1
 990              		.set	.LANCHOR2,. + 0
 993              	thisBlockLen:
 994 0000 0000     		.space	2
 995              		.section	.bss.userFirmwareLen,"aw",%nobits
 996              		.align	2
 997              		.set	.LANCHOR1,. + 0
 1000              	userFirmwareLen:
 1001 0000 00000000 		.space	4
 1002              		.section	.data.userAppEnd,"aw",%progbits
 1003              		.align	2
 1004              		.set	.LANCHOR4,. + 0
 1007              	userAppEnd:
 1008 0000 00500020 		.word	536891392
 1009              		.section	.bss.userUploadType,"aw",%nobits
 1010              		.set	.LANCHOR5,. + 0
 1013              	userUploadType:
 1014 0000 00       		.space	1
 1015              		.section	.bss.dfuAppStatus,"aw",%nobits
 1016              		.set	.LANCHOR0,. + 0
 1019              	dfuAppStatus:
 1020 0000 00000000 		.space	6
 1020      0000
 1021              		.section	.bss.dfuBusy,"aw",%nobits
 1022              		.set	.LANCHOR6,. + 0
 1025              	dfuBusy:
 1026 0000 00       		.space	1
 1027              		.section	.data.userAppAddr,"aw",%progbits
 1028              		.align	2
 1029              		.set	.LANCHOR3,. + 0
 1032              	userAppAddr:
 1033 0000 000C0020 		.word	536873984
 1034              		.text
 1035              	.Letext0:
 1036              		.file 2 "./stm32_lib/stm32f10x_type.h"
 1037              		.file 3 "./usb_lib/usb_core.h"
 1038              		.file 4 "dfu.h"
 1039              		.file 5 "./usb_lib/usb_init.h"
 1040              		.file 6 "usb.h"
 1041              		.file 7 "hardware.h"
DEFINED SYMBOLS
                            *ABS*:00000000 dfu.c
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:19     .text.dfuInit:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:24     .text.dfuInit:00000000 dfuInit
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:81     .text.dfuInit:00000038 $d
                            *COM*:00000001 code_copy_lock
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:94     .text.dfuUpdateByReset:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:99     .text.dfuUpdateByReset:00000000 dfuUpdateByReset
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:160    .text.dfuUpdateByReset:0000003c $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:166    .text.dfuUpdateByTimeout:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:171    .text.dfuUpdateByTimeout:00000000 dfuUpdateByTimeout
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:183    .text.dfuCopyState:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:188    .text.dfuCopyState:00000000 dfuCopyState
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:214    .text.dfuCopyState:00000010 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:220    .text.dfuCopyStatus:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:225    .text.dfuCopyStatus:00000000 dfuCopyStatus
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:251    .text.dfuCopyStatus:00000010 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:257    .text.dfuCopyDNLOAD:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:262    .text.dfuCopyDNLOAD:00000000 dfuCopyDNLOAD
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:296    .text.dfuCopyDNLOAD:0000001c $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:303    .text.dfuCopyUPLOAD:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:308    .text.dfuCopyUPLOAD:00000000 dfuCopyUPLOAD
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:344    .text.dfuCopyUPLOAD:00000024 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:352    .text.dfuCopyBufferToExec:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:357    .text.dfuCopyBufferToExec:00000000 dfuCopyBufferToExec
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:423    .text.dfuCopyBufferToExec:0000004c $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:431    .text.dfuUpdateByRequest:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:436    .text.dfuUpdateByRequest:00000000 dfuUpdateByRequest
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:856    .text.dfuUpdateByRequest:00000204 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:872    .text.dfuGetState:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:877    .text.dfuGetState:00000000 dfuGetState
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:892    .text.dfuGetState:00000008 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:897    .text.dfuSetState:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:902    .text.dfuSetState:00000000 dfuSetState
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:917    .text.dfuSetState:00000008 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:922    .text.dfuUploadStarted:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:927    .text.dfuUploadStarted:00000000 dfuUploadStarted
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:942    .text.dfuUploadStarted:00000008 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:947    .text.dfuFinishUpload:00000000 $t
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:952    .text.dfuFinishUpload:00000000 dfuFinishUpload
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1025   .bss.dfuBusy:00000000 dfuBusy
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1013   .bss.userUploadType:00000000 userUploadType
                            *COM*:00000004 wTransferSize
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:975    .bss.recvBuffer:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:979    .bss.recvBuffer:00000000 recvBuffer
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:982    .bss.uploadBlockLen:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:986    .bss.uploadBlockLen:00000000 uploadBlockLen
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:989    .bss.thisBlockLen:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:993    .bss.thisBlockLen:00000000 thisBlockLen
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:996    .bss.userFirmwareLen:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1000   .bss.userFirmwareLen:00000000 userFirmwareLen
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1003   .data.userAppEnd:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1007   .data.userAppEnd:00000000 userAppEnd
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1014   .bss.userUploadType:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1019   .bss.dfuAppStatus:00000000 dfuAppStatus
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1020   .bss.dfuAppStatus:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1026   .bss.dfuBusy:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1028   .data.userAppAddr:00000000 $d
C:\Users\rclark\AppData\Local\Temp\ccQGgg9j.s:1032   .data.userAppAddr:00000000 userAppAddr
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
nvicDisableInterrupts
usbEnbISR
systemHardReset
pInformation
flashErasePage
flashWriteWord
setupFLASH
flashUnlock
getFlashEnd
flashLock
